--
--  Parser
--  ------
--
--  This package contains a parser, using parse tables generated by 
--  an LALR(1) parse table generator written in SETL2.
--

package parser;

   procedure parse(source_file_name);

end parser;

package body parser;

   use token_classes,
       lexical_analyzer,
       parse_tables,
       semantic_actions;

   --
   --  Parse
   --  -----
   --
   --  This procedure is the guts of the LALR parser.
   --

   procedure parse(source_file_name);

      --
      --  Start in state 1, and continue until we accept or delete all
      --  the input.
      --

      init_lex(source_file_name);
      no_errors_yet := true;
      state_stack := [1];
      state := 1;
      token := get_token();

      loop

         action := parse_action(state,token.tok_class);

         --
         --  Accept action
         --

         if action = 1 then
            exit;

         --
         --  Reduce action
         --

         elseif action <= num_rules then

            state_stack := state_stack(1 .. #state_stack - rule_rhs(action));
            state := state_stack(#state_stack);
            state_stack with:= goto_action(goto_index(state) +
                                           rule_lhs(action));
            if no_errors_yet then
               semantic_action(action);
            end if;
            state := state_stack(#state_stack);

         --
         --  Shift action
         --

         elseif action - num_rules <= num_states then

            state_stack with:= action - num_rules;
            state := action - num_rules;
            if no_errors_yet then
               token_action(token);
            end if;
            token := get_token();

         --
         --  Error recovery
         --

         else

            print("Action => ", action);
            [token,state_stack] := poonen(token,state_stack);
            if state_stack = [] then
               exit;
            end if;
            state := state_stack(#state_stack);

         end if;

      end loop;

   end parse;

   --
   --  Poonen
   --  ------
   --
   --  This procedure recovers from syntax errors, using Poonen's method.
   --

   procedure poonen(token,orig_state_stack);

      --
      --  Before we start recovering, we have to do something to help the
      --  programmer with the error.  If we don't have an error token
      --  print an error message, then delete any error tokens.
      --

      if token.tok_class /= tok_error then
         error_message("Syntax error at "+token.tok_lexeme,
                       token.tok_line,token.tok_column);
      end if;

      while token.tok_class = tok_error loop
         token := get_token();
      end loop;

      --
      --  The first phase builds up a `beacon' set, or the set of those
      --  terminals which may reasonably follow an error, according to
      --  the grammar.
      --

      beacons := {};

      --
      --  We work our way backwards through the stack
      --

      for stack_index in [#orig_state_stack, #orig_state_stack - 1 .. 1] loop

         state_stack := orig_state_stack(1 .. stack_index);

         --
         --  Perform any reduce actions on the error token
         --

         state := state_stack(#state_stack);
         action := parse_action(state,tok_error);
         while action > 0 and action <= num_rules loop

            state_stack := state_stack(1 .. #state_stack - rule_rhs(action));
            state := state_stack(#state_stack);
            state_stack with:= goto_action(goto_index(state) +
                               rule_lhs(action) -
                               num_terminals - 1);
            state := state_stack(#state_stack);
            action := parse_action(state,tok_error);

         end loop;

         --
         --  Now we want to shift the error token, cycle if we can't
         --

         if action = 0 or action - num_rules > num_states then
            continue;
         end if;
         state_stack with:= action - num_rules;
         state := action - num_rules;

         --
         --  We search through the various token classes, looking for
         --  something which can follow an error token.
         --

         save_state_stack := state_stack;
         for terminal in [1 .. num_terminals] | beacons(terminal) = om loop

            state_stack := save_state_stack;

            --
            --  Perform any reduce actions on this token
            --

            state := state_stack(#state_stack);
            action := parse_action(state,terminal);
            while action > 0 and action <= num_rules loop

               state_stack := 
                  state_stack(1 .. #state_stack - rule_rhs(action));
               state := state_stack(#state_stack);
               state_stack with:= goto_action(goto_index(state) +
                                          rule_lhs(action) -
                                          num_terminals - 1);
               state := state_stack(#state_stack);
               action := parse_action(state,terminal);

            end loop;

            --
            --  We only keep classes we can eventually shift
            --

            if action = 0 or action - num_rules > num_states then
               continue;
            end if;

            --
            --  Let's keep the state stack, to avoid recalculation
            --

            beacons(terminal) := state_stack;

         end loop;

      end loop;

      --
      --  Now we've found the set of tokens which might follow an error
      --  token.  Search for one of them.
      --

      while token.tok_class /= tok_eof and 
            beacons(token.tok_class) = om loop
         token := get_token();
      end loop;

      --
      --  Return the new state stack, and the next token
      --

      return [token,beacons(token.tok_class) ? []];

   end poonen;

   --
   --  LPG_Action
   --  ----------
   --
   --  This procedure computes the action from the current state and
   --  token.  There really isn't anything to understand here, we have to
   --  trust Phillippe.
   --

   procedure parse_action(state,token_class);
   
      index := term_index(state) + token_class;
      if term_check(index) = token_class then
         return term_action(index);
      else
         return default_action(state);
      end if;

   end parse_action;

end parser;

