<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0051)http://toodarkpark.org/computers/objc/coreobjc.html -->
<HTML><HEAD><TITLE>The Objective-C Language</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2800.1458" name=GENERATOR></HEAD>
<BODY vLink=#8b4500 bgColor=#e0e0e0><A 
href="http://toodarkpark.org/computers/objc/oop.html"><IMG 
src="The Objective-C Language_arquivos/DocsLeftArrow.gif"></A> <A 
href="http://toodarkpark.org/computers/objc/objctoc.html"><IMG 
src="The Objective-C Language_arquivos/DocsContents.gif"></A> <A 
href="http://toodarkpark.org/computers/objc/moreobjc.html"><IMG 
src="The Objective-C Language_arquivos/DocsRightArrow.gif"></A> <A name=573></A>
<P><A name=716></A><A name=738></A>
<P><A name=722></A><I><FONT size=+3>C</FONT><FONT size=+2>hapter 2</FONT> </I>
<CENTER><FONT size=+5><B>T</B><FONT size=+0><FONT size=+4><B>he</B><FONT 
size=+0> <FONT size=+5><B>O</B><FONT size=+0><FONT 
size=+4><B>bjective-C</B><FONT size=+0> <FONT size=+5><B>L</B><FONT 
size=+0><FONT size=+4><B>anguage</B><FONT size=+0> </CENTER>
<HR>

<P><A name=1292></A>This chapter describes the Objective-C language and 
discusses the principles of object-oriented programming as they're implemented 
in Objective-C. It covers all the basic features that the language adds to 
standard C. The next chapter continues the discussion by taking up more advanced 
and less commonly used language features.
<P><A name=1293></A>Objective-C syntax is a superset of standard C syntax, and 
its compiler works for both C and Objective-C source code. The compiler 
recognizes Objective-C source files by a ``.m'' extension, just as it recognizes 
files containing only standard C syntax by a ``.c'' extension. The Objective-C 
language is fully compatible with ANSI standard C.
<P><A name=1294></A>Objective-C can also be used as an extension to C++. At 
first glance, this may seem superfluous since C++ is itself an object-oriented 
extension of C. But C++ was designed primarily as ``a better C,'' and not 
necessarily as a full-featured object-oriented language. It lacks some of the 
possibilities for object-oriented design that dynamic typing and dynamic binding 
bring to Objective-C. At the same time, it has useful language features not 
found in Objective-C. When you use the two languages in combination, you can 
assign appropriate roles to the features found in each and take advantage of 
what's best in both.
<P><A name=1295></A>Because object-oriented programs postpone many decisions 
from compile time to run time, object-oriented languages depend on a run-time 
system for executing the compiled code. The run-time system for the Objective-C 
language is discussed in <A 
href="http://toodarkpark.org/computers/objc/runtime.html#">Chapter 4</A>. This 
chapter and the next present the language, but touch on important elements of 
the run-time system as they're important for understanding language features. 
NeXT has modified the GNU C compiler to also compile Objective-C and provides 
its own run-time system.
<P><A name=1296></A>
<HR width="75%">

<CENTER><FONT size=+3>O<FONT size=+0><FONT size=+2>bjects<FONT size=+0> 
</CENTER>
<HR width="75%">

<P><A name=1297></A>As the name implies, object-oriented programs are built 
around <EM>objects</EM>. An object associates data with the particular 
operations that can use or affect that data. In Objective-C, these operations 
are known as the object's <EM>methods</EM>; the data they affect are its 
<EM>instance variables</EM>. In essence, an object bundles a data structure 
(instance variables) and a group of procedures (methods) into a self-contained 
programming unit.
<P><A name=571></A>For example, if you are writing a drawing program that allows 
a user to create images composed of lines, circles, rectangles, text, bit-mapped 
images, and so forth, you might create classes for many of the basic shapes that 
a user will be able to manipulate. A Rectangle object, for instance, might have 
instance variables that identify the position of the rectangle within the 
drawing along with its width and its height. Other instance variables could 
define the rectangle's color, whether or not it is to be filled, and a line 
pattern that should be used to display the rectangle. A Rectangle would have 
methods to set the rectangle's position, size, color, fill status, and line 
pattern, along with a method that causes the rectangle to display itself.
<P><A name=1298></A>In Objective-C, an object's instance variables are internal 
to the object; you get access to an object's state only through the object's 
methods. For others to find out something about an object, there has to be a 
method to supply the information. For example, a Rectangle would have methods 
that reveal its size and its position.
<P><A name=1299></A>Moreover, an object sees only the methods that were designed 
for it; it can't mistakenly perform methods intended for other types of objects. 
Just as a C function protects its local variables, hiding them from the rest of 
the program, an object hides both its instance variables and its method 
implementations.
<P><A name=1300></A>
<HR width="50%">

<CENTER><FONT size=+2>I<FONT size=+0><FONT size=+1>D<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1301></A>In Objective-C, objects are identified by a distinct data 
type, <STRONG>id</STRONG>. This type is defined as a pointer to an object--in 
reality, a pointer to the object's data (its instance variables). Like a C 
function or an array, an object is identified by its address. All objects, 
regardless of their instance variables or methods, are of type 
<STRONG>id</STRONG>.
<P><A name=3137></A><PRE>    id anObject;
</PRE><A name=1302></A>For the object-oriented constructs of Objective-C, such 
as method return values, <STRONG>id</STRONG> replaces <STRONG>int</STRONG> as 
the default data type. (For strictly C constructs, such as function return 
values, <STRONG>int</STRONG> remains the default type.)
<P><A name=1303></A>The keyword <STRONG>nil</STRONG> is defined as a null 
object, an <STRONG>id</STRONG> with a value of 0. <STRONG>id</STRONG>, 
<STRONG>nil</STRONG>, and the other basic types of Objective-C are defined in 
the header file <STRONG>objc.h</STRONG>, which is located in the 
<STRONG>objc</STRONG> subdirectory of <STRONG>/NextDeveloper/Headers</STRONG>.
<P><A name=1304></A>
<HR width="50%">

<CENTER><FONT size=+2>D<FONT size=+0><FONT size=+1>ynamic<FONT size=+0> <FONT 
size=+2>T<FONT size=+0><FONT size=+1>yping<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1305></A>The <STRONG>id</STRONG> type is completely nonrestrictive. 
By itself, it yields no information about an object, except that it is an 
object.
<P><A name=1306></A>But objects aren't all the same. A Rectangle won't have the 
same methods or instance variables as an object that represents a bit-mapped 
image. At some point, a program needs to find more specific information about 
the objects it contains--what the object's instance variables are, what methods 
it can perform, and so on. Since the <STRONG>id</STRONG> type designator can't 
supply this information to the compiler, each object has to be able to supply it 
at run time.
<P><A name=1307></A>This is possible because every object carries with it an 
<STRONG>isa</STRONG> instance variable that identifies the object's 
<EM>class</EM>--what kind of object it is. Every Rectangle object would be able 
to tell the run-time system that it is a Rectangle. Every Circle can say that it 
is a Circle. Objects with the same behavior (methods) and the same kinds of data 
(instance variables) are members of the same class.
<P><A name=1308></A>Objects are thus <EM>dynamically typed</EM> at run time. 
Whenever it needs to, the run-time system can find the exact class that an 
object belongs to, just by asking the object. Dynamic typing in Objective-C 
serves as the foundation for dynamic binding, discussed later.
<P><A name=1309></A>The <STRONG>isa</STRONG> pointer also enables objects to 
introspect about themselves as objects. The compiler doesn't discard much of the 
information it finds in source code; it arranges most of it in data structures 
for the run-time system to use. Through <STRONG>isa</STRONG>, objects can find 
this information and reveal it at run time. An object can, for example, say 
whether it has a particular method in its repertoire and what the name of its 
superclass is.
<P><A name=1310></A>Object classes are discussed in more detail under ``<A 
href="http://toodarkpark.org/computers/objc/coreobjc.html#1341">CLASSES</A>'' 
below.
<P><A name=1311></A>It's also possible to give the compiler information about 
the class of an object by statically typing it in source code using the class 
name. Classes are particular kinds of objects, and the class name can serve as a 
type name. See ``<A 
href="http://toodarkpark.org/computers/objc/coreobjc.html#1377">CLASS 
TYPES</A>'' later in this chapter and ``<A 
href="http://toodarkpark.org/computers/objc/moreobjc.html#">STATIC OPTIONS</A>'' 
in <A href="http://toodarkpark.org/computers/objc/moreobjc.html#">Chapter 3</A>.
<P><A name=1312></A>
<HR width="75%">

<CENTER><FONT size=+3>M<FONT size=+0><FONT size=+2>essages<FONT size=+0> 
</CENTER>
<HR width="75%">

<P><A name=1313></A>To get an object to do something, you send it a 
<EM>message</EM> telling it to apply a method. In Objective-C, <EM>message 
expressions</EM> are enclosed in square brackets:
<P><A name=3148></A><PRE>    [<EM>receiver message</EM>]
</PRE><A name=1314></A>The receiver is an object, and the message tells it what 
to do. In source code, the message is simply the name of a method and any 
arguments that are passed to it. When a message is sent, the run-time system 
selects the appropriate method from the receiver's repertoire and invokes it.
<P><A name=1315></A>For example, this message tells the <STRONG>myRect</STRONG> 
object to perform its <STRONG>display</STRONG> method, which causes the 
rectangle to display itself:
<P><A name=3155></A><PRE>    [myRect display];
</PRE><A name=1316></A>Methods can also take arguments. The imaginary message 
below tells <STRONG>myRect</STRONG> to set its location within the window to 
coordinates (30.0, 50.0):
<P><A name=3162></A><PRE>    [myRect setOrigin:30.0 :50.0];
</PRE><A name=1317></A>Here the method name, <STRONG>setOrigin::</STRONG>, has 
two colons, one for each of its arguments. The arguments are inserted after the 
colons, breaking the name apart. Colons don't have to be grouped at the end of a 
method name, as they are here. Usually a keyword describing the argument 
precedes each colon. The <STRONG>setWidth:height:</STRONG> method, for example, 
takes two arguments:
<P><A name=3174></A><PRE>    [myRect setWidth:10.0 height:15.0];
</PRE><A name=3177></A>Methods that take a variable number of arguments are also 
possible, though they're somewhat rare. Extra arguments are separated by commas 
after the end of the method name. (Unlike colons, the commas aren't considered 
part of the name.) In the following example, the imaginary 
<STRONG>makeGroup:</STRONG> method is passed one required argument 
<STRONG>(group)</STRONG> and three that are optional:
<P><A name=3182></A><PRE>    [receiver makeGroup:group, memberOne, memberTwo, memberThree];
</PRE><A name=1319></A>Like standard C functions, methods can return values. The 
following example sets the variable <STRONG>isFilled</STRONG> to True if 
<STRONG>myRect</STRONG> is drawn as a solid rectangle, or False if it's drawn in 
outline form only.
<P><A name=3189></A><PRE>    BOOL isFilled; 

    isFilled = [myRect isFilled];
</PRE><A name=1320></A>Note that a variable and a method can have the same name.
<P><A name=1321></A>One message can be nested inside another. Here one rectangle 
is set to the color of another:
<P><A name=3194></A><PRE>    [myRect setPrimaryColor:[otherRect primaryColor]];
</PRE><A name=1322></A>A message to <STRONG>nil</STRONG> also is valid,
<P><A name=3201></A><PRE>    [nil setOrigin:100.0 :22.5];
</PRE><A name=1323></A>but it has no effect and makes little sense. Messages to 
<STRONG>nil</STRONG> simply return <STRONG>nil</STRONG>.
<P><A name=1324></A>
<HR width="50%">

<CENTER><FONT size=+2>T<FONT size=+0><FONT size=+1>he<FONT size=+0> <FONT 
size=+2>R<FONT size=+0><FONT size=+1>eceiver's<FONT size=+0> <FONT 
size=+2>I<FONT size=+0><FONT size=+1>nstance<FONT size=+0> <FONT size=+2>V<FONT 
size=+0><FONT size=+1>ariables<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1325></A>A method has automatic access to the receiving object's 
instance variables. You don't need to pass them to the method as arguments. For 
example, the <STRONG>primaryColor</STRONG> method illustrated above takes no 
arguments, yet it can find the primary color for <STRONG>otherRect</STRONG> and 
return it. Every method assumes the receiver and its instance variables, without 
having to declare them as arguments.
<P><A name=1326></A>This convention simplifies Objective-C source code. It also 
supports the way object-oriented programmers think about objects and messages. 
Messages are sent to receivers much as letters are delivered to your home. 
Message arguments bring information from the outside to the receiver; they don't 
need to bring the receiver to itself.
<P><A name=1327></A>A method has automatic access only to the receiver's 
instance variables. If it requires information about a variable stored in 
another object, it must send a message to the object asking it to reveal the 
contents of the variable. The <STRONG>primaryColor</STRONG> and 
<STRONG>isFilled</STRONG> methods shown above are used for just this purpose.
<P><A name=1328></A>See ``<A 
href="http://toodarkpark.org/computers/objc/coreobjc.html#1445">DEFINING A 
CLASS</A>'' for more information on referring to instance variables.
<P><A name=1329></A>
<HR width="50%">

<CENTER><FONT size=+2>P<FONT size=+0><FONT size=+1>olymorphism<FONT size=+0> 
</CENTER>
<HR width="50%">

<P><A name=1330></A>As the examples above illustrate, messages in Objective-C 
appear in the same syntactic positions as function calls in standard C. But, 
because methods ``belong to'' an object, messages behave differently than 
function calls.
<P><A name=1331></A>In particular, an object has access only to the methods that 
were defined for it. It can't confuse them with methods defined for other kinds 
of objects, even if another object has a method with the same name. This means 
that two objects can respond differently to the same message. For example, each 
kind of object sent a <STRONG>display</STRONG> message could display itself in a 
unique way. A Circle and a Rectangle would respond differently to identical 
instructions to track the cursor.
<P><A name=1332></A>This feature, referred to as <EM>polymorphism</EM>, plays a 
significant role in the design of object-oriented programs. Together with 
dynamic binding, it permits you to write code that might apply to any number of 
different kinds of objects, without your having to choose at the time you write 
the code what kinds of objects they might be. They might even be objects that 
will be developed later, by other programmers working on other projects. If you 
write code that sends a display message to an <STRONG>id</STRONG> variable, any 
object that has a <STRONG>display</STRONG> method is a potential receiver.
<P><A name=1333></A>
<HR width="50%">

<CENTER><FONT size=+2>D<FONT size=+0><FONT size=+1>ynamic<FONT size=+0> <FONT 
size=+2>B<FONT size=+0><FONT size=+1>inding<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1334></A>A crucial difference between function calls and messages is 
that a function and its arguments are joined together in the compiled code, but 
a message and a receiving object aren't united until the program is running and 
the message is sent. Therefore, the exact method that will be invoked to respond 
to a message can only be determined at run time, not when the code is compiled.
<P><A name=1335></A>The precise method that a message invokes depends on the 
receiver. Different receivers may have different method implementations for the 
same method name (polymorphism). For the compiler to find the right method 
implementation for a message, it would have to know what kind of object the 
receiver is--what class it belongs to. This is information the receiver is able 
to reveal at run time when it receives a message (dynamic typing), but it's not 
available from the type declarations found in source code.
<P><A name=1336></A>The selection of a method implementation happens at run 
time. When a message is sent, a run-time messaging routine looks at the receiver 
and at the method named in the message. It locates the receiver's implementation 
of a method matching the name, ``calls'' the method, and passes it a pointer to 
the receiver's instance variables. (For more on this routine, see ``<A 
href="http://toodarkpark.org/computers/objc/coreobjc.html#1522">HOW MESSAGING 
WORKS</A>'' below.)
<P><A name=1337></A>The method name in a message thus serves to ``select'' a 
method implementation. For this reason, method names in messages are often 
referred to as <EM>selectors</EM>.
<P><A name=1338></A>This <EM>dynamic binding</EM> of methods to messages works 
hand-in-hand with polymorphism to give object-oriented programming much of its 
flexibility and power. Since each object can have its own version of a method, a 
program can achieve a variety of results, not by varying the message itself, but 
by varying just the object that receives the message. This can be done as the 
program runs; receivers can be decided ``on the fly'' and can be made dependent 
on external factors such as user actions.
<P><A name=1339></A>When executing code based upon the Application Kit, for 
example, users determine which objects receive messages from menu commands like 
Cut, Copy, and Paste. The message goes to whatever object controls the current 
selection. An object that displays editable text would react to a 
<STRONG>copy</STRONG> message differently than an object that displays scanned 
images. An object that represents a set of shapes would respond differently than 
a Rectangle. Since messages don't select methods (methods aren't bound to 
messages) until run time, these differences are isolated in the methods that 
respond to the message. The code that sends the message doesn't have to be 
concerned with them; it doesn't even have to enumerate the possibilities. Each 
application can invent its own objects that respond in their own way to 
<STRONG>copy:</STRONG> messages.
<P><A name=1340></A>Objective-C takes dynamic binding one step further and 
allows even the message that's sent (the method selector) to be a variable 
that's determined at run time. This is discussed in the section on ``<A 
href="http://toodarkpark.org/computers/objc/coreobjc.html#1522">HOW MESSAGING 
WORKS</A>.''
<P><A name=1341></A>
<HR width="75%">

<CENTER><FONT size=+3>C<FONT size=+0><FONT size=+2>lasses<FONT size=+0> 
</CENTER>
<HR width="75%">

<P><A name=1342></A>An object-oriented program is typically built from a variety 
of objects. A program based on the OPENSTEP software frameworks might use 
NSMatrix objects, NSWindow objects, NSDictionary objects, NSFont objects, NSText 
objects, and many others. Programs often use more than one object of the same 
kind or <EM>class</EM>--several NSArrays or NSWindows, for example.
<P><A name=1343></A>In Objective-C, you define objects by defining their class. 
The class definition is a prototype for a kind of object; it declares the 
instance variables that become part of every member of the class, and it defines 
a set of methods that all objects in the class can use.
<P><A name=1344></A>The compiler creates just one accessible object for each 
class, a <EM>class object</EM> that knows how to build new objects belonging to 
the class. (For this reason it's sometimes also called a ``factory object.'') 
The class object is the compiled version of the class; the objects it builds are 
<EM>instances</EM> of the class. The objects that will do the main work of your 
program are instances created by the class object at run time.
<P><A name=1345></A>All instances of a class have access to the same set of 
methods, and they all have a set of instance variables cut from the same mold. 
Each object gets its own instance variables, but the methods are shared.
<P><A name=1346></A>By convention, class names begin with an uppercase letter 
(such as ``Rectangle''); the names of instances typically begin with a lowercase 
letter (such as ``myRect'').
<P><A name=1347></A>
<HR width="50%">

<CENTER><FONT size=+2>I<FONT size=+0><FONT size=+1>nheritance<FONT size=+0> 
</CENTER>
<HR width="50%">

<P><A name=1348></A>Class definitions are additive; each new class that you 
define is based on another class through which it <EM>inherits</EM> methods and 
instance variables. The new class simply adds to or modifies what it inherits. 
It doesn't need to duplicate inherited code.
<P><A name=1349></A>Inheritance links all classes together in a hierarchical 
tree with a single class at its root. When writing code that is based upon the 
Foundation framework, that root class is typically NSObject. Every class (except 
a root class) has a <EM>superclass</EM> one step nearer the root, and any class 
(including a root class) can be the superclass for any number of 
<EM>subclasses</EM> one step farther from the root. The figure below illustrates 
the hierarchy for a few of the classes used in the drawing program.
<P><A name=574></A>
<P><IMG hspace=10 src="" align=left> <A name=1350></A>This figure shows that the 
Square class is a subclass of the Rectangle class, the Rectangle class is a 
subclass of Shape, Shape is a subclass of Graphic, and Graphic is a subclass of 
NSObject. Inheritance is cumulative. So a Square object has the methods and 
instance variables defined for Rectangle, Shape, Graphic, and NSObject, as well 
as those defined specifically for Square. This is simply to say that a Square 
object isn't only a Square, it's also a Rectangle, a Shape, a Graphic, and an 
NSObject.
<P><A name=1351></A>Every class but NSObject can thus be seen as a 
specialization or an adaptation of another class. Each successive subclass 
further modifies the cumulative total of what's inherited. The Square class 
defines only the minimum needed to turn a Rectangle into a Square.
<P><A name=1352></A>When you define a class, you link it to the hierarchy by 
declaring its superclass; every class you create must be the subclass of another 
class (unless you define a new root class). Plenty of potential superclasses are 
available. OPENSTEP includes the NSObject class and several software frameworks 
containing definitions for more than 125 additional classes. Some are classes 
that you can use ``off the shelf''--incorporate into your program as is. Others 
you might want to adapt to your own needs by defining a subclass.
<P><A name=1353></A>Some framework classes define almost everything you need, 
but leave some specifics to be implemented in a subclass. You can thus create 
very sophisticated objects by writing only a small amount of code, and reusing 
work done by the programmers of the framework.
<P><A name=1354></A>
<H3>The NSObject Class</H3><A name=1355></A>NSObject, being a root class, 
doesn't have a superclass. In OPENSTEP, it's in the inheritance path for every 
other class. That's because it defines the basic framework for Objective-C 
objects and object interactions. It imparts to the classes and instances that 
inherit from it the ability to behave as objects and cooperate with the run-time 
system.
<P><A name=1356></A>A class that doesn't need to inherit any special behavior 
from another class is nevertheless made a subclass of the NSObject class. 
Instances of the class must at least have the ability to behave like Objective-C 
objects at run time. Inheriting this ability from the NSObject class is much 
simpler and much more reliable than reinventing it in a new class definition.
<P><A name=1357></A>Note: Implementing a new root class is a delicate task and 
one with many hidden hazards. The class must duplicate much of what the NSObject 
class does, such as allocate instances, connect them to their class, and 
identify them to the run-time system. It's strongly recommended that you use the 
NSObject class provided with OPENSTEP as the root class. This manual doesn't 
explain all the ins and outs that you would need to know to replace it. <PRE></PRE><A name=1358></A>
<H3>Inheriting Instance Variables</H3><A name=1359></A>When a class object 
creates a new instance, the new object contains not only the instance variables 
that were defined for its class, but also the instance variables defined for its 
superclass, and for its superclass's superclass, all the way back to the root 
class. Thus, the <STRONG>isa</STRONG> instance variable defined in the NSObject 
class becomes part of every object. <STRONG>isa</STRONG> connects each object to 
its class.
<P><A name=1360></A>The figure below shows some of the instance variables that 
could be defined for a particular implementation of Rectangle, and where they 
might come from. Note that the variables that make the object a Rectangle are 
added to the ones that make it a Shape, and the ones that make it a Shape are 
added to the ones that make it a Graphic, and so on.
<P><A name=575></A>
<P><IMG hspace=10 src="" align=left> <A name=1361></A>A class doesn't have to 
declare instance variables. It can simply define new methods and rely on the 
instance variables it inherits, if it needs any instance variables at all. For 
instance, Square might not declare any new instance variables of its own.<BR 
clear=all>
<P><A name=1362></A>
<H3>Inheriting Methods</H3><A name=1363></A>An object has access not only to the 
methods that were defined for its class, but also to methods defined for its 
superclass, and for its superclass's superclass, all the way back to the root of 
the hierarchy. For instance, a Square object can use methods defined in the 
Rectangle, Shape, Graphic, and NSObject classes as well as methods defined in 
its own class.
<P><A name=1364></A>Any new class you define in your program can therefore make 
use of the code written for all the classes above it in the hierarchy. This type 
of inheritance is a major benefit of object-oriented programming. When you use 
one of the object-oriented frameworks provided by OPENSTEP, your programs can 
take advantage of all the basic functionality coded into the framework classes. 
You have to add only the code that customizes the framework to your application.
<P><A name=1365></A>Class objects also inherit from the classes above them in 
the hierarchy. But because they don't have instance variables (only instances 
do), they inherit only methods.
<P><A name=1366></A>
<H3>Overriding One Method with Another</H3><A name=1367></A>There's one useful 
exception to inheritance: When you define a new class, you can implement a new 
method with the same name as one defined in a class farther up the hierarchy. 
The new method overrides the original; instances of the new class will perform 
it rather than the original, and subclasses of the new class will inherit it 
rather than the original.
<P><A name=1368></A>For example, Graphic defines a <STRONG>display</STRONG> 
method that Rectangle overrides by defining its own version of 
<STRONG>display</STRONG>. The Graphic method is available to all kinds of 
objects that inherit from the Graphic class--but not to Rectangle objects, which 
instead perform the Rectangle version of <STRONG>display</STRONG>.
<P><A name=1369></A>Although overriding a method blocks the original version 
from being inherited, other methods defined in the new class can skip over the 
redefined method and find the original (see ``<A 
href="http://toodarkpark.org/computers/objc/coreobjc.html#1580">MESSAGES TO SELF 
AND SUPER</A>,'' below, to learn how).
<P><A name=1370></A>A redefined method can also incorporate the very method it 
overrides. When it does, the new method serves only to refine or modify the 
method it overrides, rather than replace it outright. When several classes in 
the hierarchy define the same method, but each new version incorporates the 
version it overrides, the implementation of the method is effectively spread 
over all the classes.
<P><A name=1371></A>Although a subclass can override inherited methods, it can't 
override inherited instance variables. Since an object has memory allocated for 
every instance variable it inherits, you can't override an inherited variable by 
declaring a new one with the same name. If you try, the compiler will complain.
<P><A name=1372></A>
<H3>Abstract Classes</H3><A name=1373></A>Some classes are designed only so that 
other classes can inherit from them. These <EM>abstract classes</EM> group 
methods and instance variables that will be used by a number of different 
subclasses into a common definition. The abstract class is incomplete by itself, 
but contains useful code that reduces the implementation burden of its 
subclasses.
<P><A name=1374></A>The NSObject class is the prime example of an abstract 
class. Although programs often define NSObject subclasses and use instances 
belonging to the subclasses, they never use instances belonging directly to the 
NSObject class. An NSObject instance wouldn't be good for anything; it would be 
a generic object with the ability to do nothing in particular.
<P><A name=1375></A>Abstract classes often contain code that helps define the 
structure of an application. When you create subclasses of these classes, 
instances of your new classes fit effortlessly into the application structure 
and work automatically with other objects.
<P><A name=1376></A>(Because abstract classes must have subclasses, they're 
sometimes also called <EM>abstract superclasses</EM>.)
<P><A name=1377></A>
<HR width="50%">

<CENTER><FONT size=+2>C<FONT size=+0><FONT size=+1>lass<FONT size=+0> <FONT 
size=+2>T<FONT size=+0><FONT size=+1>ypes<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1378></A>A class definition is a specification for a kind of object. 
The class, in effect, defines a data type. The type is based not just on the 
data structure the class defines (instance variables), but also on the behavior 
included in the definition (methods).
<P><A name=1379></A>A class name can appear in source code wherever a type 
specifier is permitted in C--for example, as an argument to the 
<STRONG>sizeof</STRONG> operator:
<P><A name=3210></A><PRE>    int i = sizeof(Rectangle);
</PRE><A name=1380></A>
<H3>Static Typing</H3><A name=1381></A>You can use a class name in place of 
<STRONG>id</STRONG> to designate an object's type:
<P><A name=3217></A><PRE>    Rectangle *myRect;
</PRE><A name=1382></A>Since this way of declaring an object type gives the 
compiler information about what kind of object it is, it's known as <EM>static 
typing</EM>. Just as <STRONG>id</STRONG> is defined as a pointer to an object, 
objects are statically typed as pointers to a class. Objects are always typed by 
a pointer. Static typing makes the pointer explicit; <STRONG>id</STRONG> hides 
it.
<P><A name=1383></A>Static typing permits the compiler to do some type 
checking--for example, to warn if an object receives a message that it appears 
not to be able to respond to--and to loosen some restrictions that apply to 
objects generically typed <STRONG>id</STRONG>. In addition, it can make your 
intentions clearer to others who read your source code. However, it doesn't 
defeat dynamic binding or alter the dynamic determination of a receiver's class 
at run time.
<P><A name=1384></A>An object can be statically typed to its own class or to any 
class that it inherits from. For example, since inheritance makes a Rectangle a 
kind of Graphic, a Rectangle instance could be statically typed to the Graphic 
class:
<P><A name=3224></A><PRE>    Graphic *myRect;
</PRE><A name=1385></A>This is possible because a Rectangle is a Graphic. It's 
more than a Graphic since it also has the instance variables and method 
capabilities of a Shape and a Rectangle, but it's a Graphic nonetheless. For 
purposes of type checking, the compiler will consider <STRONG>myRect</STRONG> to 
be an Graphic, but at run time it will be treated as a Rectangle.
<P><A name=1386></A>See ``<A 
href="http://toodarkpark.org/computers/objc/moreobjc.html#">STATIC OPTIONS</A>'' 
in the next chapter for more on static typing and its benefits.
<P><A name=1387></A>
<H3>Type Introspection</H3><A name=1388></A>Instances can reveal their types at 
run time. The <STRONG>isMemberOfClass:</STRONG> method, defined in the NSObject 
class, checks whether the receiver is an instance of a particular class:
<P><A name=3231></A><PRE>    if ( [anObject isMemberOfClass:someClass] )
	    . . .
</PRE><A name=1389></A>The <STRONG>isKindOfClass:</STRONG> method, also defined 
in the NSObject class, checks more generally whether the receiver inherits from 
or is a member of a particular class (whether it has the class in its 
inheritance path):
<P><A name=3239></A><PRE>    if ( [anObject isKindOfClass:someClass] )
	    . . .
</PRE><A name=1390></A>The set of classes for which 
<STRONG>isKindOfClass:</STRONG> returns YES is the same set to which the 
receiver can be statically typed.
<P><A name=1391></A>Introspection isn't limited to type information. Later 
sections of this chapter discuss methods that return the class object, report 
whether an object can respond to a message, and reveal other information.
<P><A name=1392></A>See the NSObject class specification in the <EM>Foundation 
Framework Reference</EM> for more on <STRONG>isKindOfClass:</STRONG>, 
<STRONG>isMemberOfClass:</STRONG>, and related methods.
<P><A name=1393></A>
<HR width="50%">

<CENTER><FONT size=+2>C<FONT size=+0><FONT size=+1>lass<FONT size=+0> <FONT 
size=+2>O<FONT size=+0><FONT size=+1>bjects<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1394></A>A class definition contains various kinds of information, 
much of it about instances of the class:
<P>
<UL><A name=1395></A>
  <LI>The name of the class and its superclass <A name=1396></A>
  <LI>A template describing a set of instance variables <A name=1397></A>
  <LI>The declaration of method names and their return and argument types <A 
  name=1398></A>
  <LI>The method implementations </LI></UL><A name=1399></A>This information is 
compiled and recorded in data structures made available to the run-time system. 
The compiler creates just one object, a <EM>class object</EM>, to represent the 
class. The class object has access to all the information about the class, which 
means mainly information about what instances of the class are like. It's able 
to produce new instances according to the plan put forward in the class 
definition.
<P><A name=1400></A>Although a class object keeps the prototype of a class 
instance, it's not an instance itself. It has no instance variables of its own 
and it can't perform methods intended for instances of the class. However, a 
class definition can include methods intended specifically for the class 
object--<EM>class methods</EM> as opposed to <EM>instance methods</EM>. A class 
object inherits class methods from the classes above it in the hierarchy, just 
as instances inherit instance methods.
<P><A name=1401></A>In source code, the class object is represented by the class 
name. In the following example, the Rectangle class returns the class version 
number using a method inherited from the NSObject class:
<P><A name=3257></A><PRE>    int versionNumber = [Rectangle version];
</PRE><A name=1402></A>However, the class name stands for the class object only 
as the receiver in a message expression. Elsewhere, you need to ask an instance 
or the class to return the class <STRONG>id</STRONG>. Both respond to a 
<STRONG>class</STRONG> message:
<P><A name=3266></A><PRE>    id aClass    = [anObject class];
    id rectClass = [Rectangle class];
</PRE><A name=1403></A>As these examples show, class objects can, like all other 
objects, be typed </STRONG>id</STRONG>. But class objects can also be more 
specifically typed to the Class data type:
<P><A name=3275></A><PRE>    Class aClass    = [anObject class];
    Class rectClass = [Rectangle class];
</PRE><A name=1404></A>All class objects are of type Class. Using this type name 
for a class is equivalent to using the class name to statically type an 
instance.
<P><A name=1405></A>Class objects are thus full-fledged objects that can be 
dynamically typed, receive messages, and inherit methods from other classes. 
They're special only in that they're created by the compiler, lack data 
structures (instance variables) of their own other than those built from the 
class definition, and are the agents for producing instances at run time.
<P><A name=1406></A>Note: The compiler also builds a ``meta-class object'' for 
each class. It describes the class object just as the class object describes 
instances of the class. But while you can send messages to instances and to the 
class object, the meta-class object is used only internally by the run-time 
system. <A name=1407></A>
<H3>Creating Instances</H3><A name=1408></A>A principal function of a class 
object is to create new instances. This code tells the Rectangle class to create 
a new Rectangle instance and assign it to the <STRONG>myRect</STRONG> variable:
<P><A name=3734></A><PRE>    id  myRectx; 

    myRect = [Rectangle alloc];
</PRE><A name=1409></A>The <STRONG>alloc</STRONG> method dynamically allocates 
memory for the new object's instance variables and initializes them all to 
0--all, that is, except the <STRONG>isa</STRONG> variable that connects the new 
instance to its class. For an object to be useful, it generally needs to be more 
completely initialized. That's the function of an <STRONG>init</STRONG> method. 
Initialization typically follows immediately after allocation:
<P><A name=3741></A><PRE>    myRect = [[Rectangle alloc] init];
</PRE><A name=1410></A>This line of code, or one like it, would be necessary 
before <STRONG>myRect</STRONG> could receive any of the messages that were 
illustrated in previous examples in this chapter. The <STRONG>alloc</STRONG> 
method returns a new instance and that instance performs an 
<STRONG>init</STRONG> method to set its initial state. Every class object has at 
least one method (like <STRONG>alloc</STRONG>) that enables it to produce new 
objects, and every instance has at least one method (like <STRONG>init</STRONG>) 
that prepares it for use. Initialization methods often take arguments to allow 
particular values to be passed and have keywords to label the arguments 
(<STRONG>initWithPosition:Size:</STRONG>, for example, is a method that might 
initialize a new Rectangle instance), but they all begin with ``init''.
<P><A name=1411></A>
<H3>Customization with Class Objects</H3><A name=1412></A>It's not just a whim 
of the Objective-C language that classes are treated as objects. It's a choice 
that has intended, and sometimes surprising, benefits for design. It's possible, 
for example, to customize an object with a class, where the class belongs to an 
open-ended set. In the Application Kit, for example, an NSMatrix object can be 
customized with a particular kind of NSCell.
<P><A name=1413></A>An NSMatrix can take responsibility for creating the 
individual objects that represent its cells. It can do this when the NSMatrix is 
first initialized and later when new cells are needed. The visible matrix that 
an NSMatrix object draws on-screen can grow and shrink at run time, perhaps in 
response to user actions. When it grows, the NSMatrix needs to be able to 
produce new objects to fill the new slots that are added.
<P><A name=1414></A>But what kind of objects should they be? Each NSMatrix 
displays just one kind of NSCell, but there are many different kinds. The 
inheritance hierarchy in the following figure shows some of those provided by 
the Application Kit. All inherit from the generic NSCell class:
<P><A name=1415></A>
<P><IMG hspace=10 src="" align=left> <A name=1416></A>When an NSMatrix creates 
new NSCell objects, should they be NSButtonCells to display a bank of buttons or 
switches, NSTextFieldCells to display a field where the user can enter and edit 
text, or some other kind of NSCell? The NSMatrix must allow for any kind of 
NSCell, even types that haven't been invented yet.
<P><A name=1417></A>One solution to this problem would be to define the NSMatrix 
class as an abstract class and require everyone who uses it to declare a 
subclass and implement the methods that produce new cells. Because they would be 
implementing the methods, users of the class could be sure that the objects they 
created were of the right type.
<P><A name=1418></A>But this requires others to do work that ought to be done in 
the NSMatrix class, and it unnecessarily proliferates the number of classes. 
Since an application might need more than one kind of NSMatrix, each with a 
different kind of NSCell, it could become cluttered with NSMatrix subclasses. 
Every time you invented a new kind of NSCell, you'd also have to define a new 
kind of NSMatrix. Moreover, programmers on different projects would be writing 
virtually identical code to do the same job, all to make up for NSMatrix's 
failure to do it.
<P><A name=1419></A>A better solution, the solution the NSMatrix class actually 
adopts, is to allow NSMatrix instances to be initialized with a kind of 
NSCell--with a class object. It defines a <STRONG>setCellClass:</STRONG> method 
that passes the class object for the kind of NSCell object an NSMatrix should 
use to fill empty slots:
<P><A name=3283></A><PRE>    [myMatrix setCellClass:[NSButtonCell class]];
</PRE><A name=1420></A>The NSMatrix uses the class object to produce new cells 
when it's first initialized and whenever it's resized to contain more cells. 
This kind of customization would be impossible if classes weren't objects that 
could be passed in messages and assigned to variables.
<P><A name=1421></A>
<H3>Variables and Class Objects</H3><A name=1422></A>When you define a new class 
of objects, you can decide what instance variables they should have. Every 
instance of the class will have its own copy of all the variables you declare; 
each object controls its own data.
<P><A name=1423></A>However, you can't prescribe variables for the class object; 
there are no ``class variable'' counterparts to instance variables. Only 
internal data structures, initialized from the class definition, are provided 
for the class. The class object also has no access to the instance variables of 
any instances; it can't initialize, read, or alter them.
<P><A name=1424></A>Therefore, for all the instances of a class to share data, 
an external variable of some sort is required. Some classes declare static 
variables and provide class methods to manage them. (Declaring a variable 
<STRONG>static</STRONG> in the same file as the class definition limits its 
scope to just the class--and to just the part of the class that's implemented in 
the file. Unlike instance variables, static variables can't be inherited by 
subclasses, unless the subclasses are defined in the same file.)
<P><A name=1425></A>Static variables help give the class object more 
functionality than just that of a ``factory'' producing instances; it can 
approach being a complete and versatile object in its own right. A class object 
can be used to coordinate the instances it creates, dispense instances from 
lists of objects already created, or manage other processes essential to the 
application. In the limiting case, when you need only one object of a particular 
class, you can put all the object's state into static variables and use only 
class methods. This saves the step of allocating and initializing an instance.
<P><A name=1426></A>Note: It would also be possible to use external variables 
that weren't declared static, but the limited scope of static variables better 
serves the purpose of encapsulating data into separate objects. <A 
name=1427></A>
<H3>Initializing a Class Object</H3><A name=1428></A>If a class object is to be 
used for anything besides allocating instances, it may need to be initialized 
just as an instance is. Although programs don't allocate class objects, 
Objective-C does provide a way for programs to initialize them.
<P><A name=1429></A>The run-time system sends an <STRONG>initialize</STRONG> 
message to every class object before the class receives any other messages. This 
gives the class a chance to set up its run-time environment before it's used. If 
no initialization is required, you don't need to write an 
<STRONG>initialize</STRONG> method to respond to the message; the NSObject class 
defines an empty version that your class can inherit and perform.
<P><A name=1430></A>If a class makes use of static or global variables, the 
<STRONG>initialize</STRONG> method is a good place to set their initial values. 
For example, if a class maintains an array of instances, the 
<STRONG>initialize</STRONG> method could set up the array and even allocate one 
or two default instances to have them ready.
<P><A name=1431></A>
<H3>Methods of the Root Class</H3><A name=1432></A>All objects, classes and 
instances alike, need an interface to the run-time system. Both class objects 
and instances should be able to introspect about their abilities and to report 
their place in the inheritance hierarchy. It's the province of the NSObject 
class to provide this interface.
<P><A name=1433></A>So that NSObject's methods won't all have to be implemented 
twice--once to provide a run-time interface for instances and again to duplicate 
that interface for class objects--class objects are given special dispensation 
to perform instance methods defined in the root class. When a class object 
receives a message that it can't respond to with a class method, the run-time 
system will see if there's a root instance method that can respond. The only 
instance methods that a class object can perform are those defined in the root 
class, and only if there's no class method that can do the job.
<P><A name=1434></A>For more on this peculiar ability of class objects to 
perform root instance methods, see the NSObject class specification in the 
<EM>Foundation Framework Reference</EM>.
<P><A name=1435></A>
<HR width="50%">

<CENTER><FONT size=+2>C<FONT size=+0><FONT size=+1>lass<FONT size=+0> <FONT 
size=+2>N<FONT size=+0><FONT size=+1>ames in<FONT size=+0> <FONT size=+2>S<FONT 
size=+0><FONT size=+1>ource<FONT size=+0> <FONT size=+2>C<FONT size=+0><FONT 
size=+1>ode<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1436></A>In source code, class names can be used in only two very 
different contexts. These contexts reflect the dual role of a class as a data 
type and as an object:
<P>
<UL><A name=1437></A>
  <LI>The class name can be used as a type name for a kind of object. For 
  example: <A name=3290></A><PRE>	Rectangle *anObject;

	anObject = [[Rectangle alloc] init];
    </PRE>
  <DL><A name=1438></A>
    <DT>Here <STRONG>anObject</STRONG> is statically typed to be a Rectangle. 
    The compiler will expect it to have the data structure of a Rectangle 
    instance and the instance methods defined and inherited by the Rectangle 
    class. Static typing enables the compiler to do better type checking and 
    makes source code more self-documenting. See ``<A 
    href="http://toodarkpark.org/computers/objc/moreobjc.html#">STATIC 
    OPTIONS</A>'' in the next chapter for details. <A name=1439></A>
    <DT>Only instances can be statically typed; class objects can't be, since 
    they aren't members of a class, but rather belong to the Class data type. 
    </DT></DL><A name=3305></A>
  <LI>As the receiver in a message expression, the class name refers to the 
  class object. This usage was illustrated in several of the examples above. The 
  class name can stand for the class object only as a message receiver. In any 
  other context, you must ask the class object to reveal its <STRONG>id</STRONG> 
  (by sending it a <STRONG>class</STRONG> message). The example below passes the 
  Rectangle class as an argument in an <STRONG>isKindOf:</STRONG> message. <A 
  name=3315></A><PRE>	if ( [anObject isKindOf:[Rectangle class]] )
	    . . .
    </PRE>
  <DL><A name=1441></A>
    <DT>It would have been illegal to simply use the name ``Rectangle'' as the 
    argument. The class name can only be a receiver. <A name=1442></A>
    <DT>If you don't know the class name at compile time but have it as a string 
    at run time, <STRONG>objc_lookUpClass()</STRONG> will return the class 
    object: <A name=3322></A><PRE>	if ( [anObject isKindOf:objc_lookUpClass(aBuffer)] )
	    . . .
    </PRE><A name=1443></A>
    <DT>This function returns <STRONG>nil</STRONG> if the string it's passed is 
    not a valid class name. </DT></DL></LI></UL><A name=1444></A>Class names compete 
in the same name space as variables and functions. A class and a global variable 
can't have the same name. Class names are about the only names with global 
visibility in Objective-C.
<P><A name=1445></A>
<HR width="75%">

<CENTER><FONT size=+3>D<FONT size=+0><FONT size=+2>efining a<FONT size=+0> <FONT 
size=+3>C<FONT size=+0><FONT size=+2>lass<FONT size=+0> </CENTER>
<HR width="75%">

<P><A name=1446></A>Much of object-oriented programming consists of writing the 
code for new objects--defining new classes. In Objective-C, classes are defined 
in two parts:
<P>
<UL><A name=1447></A>
  <LI>An <EM>interface</EM> that declares the methods and instance variables of 
  the class and names its superclass <A name=1448></A>
  <LI>An <EM>implementation</EM> that actually defines the class (contains the 
  code that implements its methods) </LI></UL><A name=1449></A>Although the 
compiler doesn't require it, the interface and implementation are usually 
separated into two different files. The interface file must be made available to 
anyone who uses the class. You generally wouldn't want to distribute the 
implementation file that widely; users don't need source code for the 
implementation.
<P><A name=1450></A>A single file can declare or implement more than one class. 
Nevertheless, it's customary to have a separate interface file for each class, 
if not also a separate implementation file. Keeping class interfaces separate 
better reflects their status as independent entities.
<P><A name=1451></A>Interface and implementation files typically are named after 
the class. The implementation file has a ``.m'' suffix, indicating that it 
contains Objective-C source code. The interface file can be assigned any other 
extension. Because it's included in other source files, the interface file 
usually has the ``.h'' suffix typical of header files. For example, the 
Rectangle class would be declared in <STRONG>Rectangle.h</STRONG> and defined in 
<STRONG>Rectangle.m</STRONG>.
<P><A name=1452></A>Separating an object's interface from its implementation 
fits well with the design of object-oriented programs. An object is a 
self-contained entity that can be viewed from the outside almost as a ``black 
box.'' Once you've determined how an object will interact with other elements in 
your program--that is, once you've declared its interface--you can freely alter 
its implementation without affecting any other part of the application.
<P><A name=1453></A>
<HR width="50%">

<CENTER><FONT size=+2>T<FONT size=+0><FONT size=+1>he<FONT size=+0> <FONT 
size=+2>I<FONT size=+0><FONT size=+1>nterface<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1454></A>The declaration of a class interface begins with the 
compiler directive <STRONG>@interface</STRONG> and ends with the directive 
<STRONG>@end</STRONG>. (All Objective-C directives to the compiler begin with 
``@''.)
<P><A name=3329></A><PRE>    @interface <EM>ClassName</EM> <STRONG>:</STRONG> <EM>ItsSuperclass </EM>
    {

	    <EM>instance variable declarations</EM>

    }

    <EM>method declarations</EM>

    @end
</PRE><A name=1455></A>The first line of the declaration presents the new class 
name and links it to its superclass. The superclass defines the position of the 
new class in the inheritance hierarchy, as discussed under ``<A 
href="http://toodarkpark.org/computers/objc/coreobjc.html#1347">INHERITANCE</A>'' 
above. If the colon and superclass name are omitted, the new class is declared 
as a root class, a rival to the NSObject class.
<P><A name=1456></A>Following the class declaration, braces enclose declarations 
of <EM>instance variables</EM>, the data structures that will be part of each 
instance of the class. Here's a partial list of instance variables that might be 
declared in the Rectangle class:
<P><A name=3347></A><PRE>    float width
</PRE><A name=3353></A><PRE>    float height;
</PRE><A name=3348></A><PRE>    BOOL filled;
</PRE><A name=3349></A><PRE>    NSColor *fillColor;
</PRE><A name=1457></A>Methods for the class are declared next, after the braces 
enclosing instance variables and before the end of the class declaration. The 
names of methods that can be used by class objects, <EM>class methods</EM>, are 
preceded by a plus sign:
<P><A name=3360></A><PRE>    + alloc;
</PRE><A name=1458></A>The methods that instances of a class can use, 
<EM>instance methods</EM>, are marked with a minus sign:
<P><A name=3370></A><PRE>    - (void)display;
</PRE><A name=1459></A>Although it's not a common practice, you can define a 
class method and an instance method with the same name. A method can also have 
the same name as an instance variable. This is more common, especially if the 
method returns the value in the variable. For example, Circle has a 
<STRONG>radius</STRONG> method that could match a <STRONG>radius</STRONG> 
instance variable.
<P><A name=1460></A>Method return types are declared using the standard C syntax 
for casting one type to another:
<P><A name=3380></A><PRE>    - (float)radius;
</PRE><A name=1461></A>Argument types are declared in the same way:
<P><A name=3386></A>- setRadius:(float)aRadius;
<P><A name=1462></A>If a return or argument type isn't explicitly declared, it's 
assumed to be the default type for methods and messages--an <STRONG>id</STRONG>. 
The <STRONG>alloc</STRONG> and <STRONG>setRadius:</STRONG> methods illustrated 
above both return <STRONG>id</STRONG>s.
<P><A name=1463></A>When there's more than one argument, they're declared within 
the method name after the colons. Arguments break the name apart in the 
declaration, just as in a message. For example:
<P><A name=3393></A><PRE>    - (void)setWidth:(float)width: height:(float)height;
</PRE><A name=1464></A>Methods that take a variable number of arguments declare 
them using a comma and an ellipsis, just as a function would:
<P><A name=3401></A><PRE>    - makeGroup:group, ...;
</PRE><A name=1465></A>
<H3>Importing the Interface</H3><A name=1466></A>The interface file must be 
included in any source module that depends on the class interface--that includes 
any module that creates an instance of the class, sends a message to invoke a 
method declared for the class, or mentions an instance variable declared in the 
class. The interface is usually included with the <STRONG>#import</STRONG> 
directive:
<P><A name=3408></A><PRE>    #import "Rectangle.h"
</PRE><A name=1467></A>This directive is identical to <STRONG>#include</STRONG>, 
except that it makes sure that the same file is never included more than once. 
It's therefore preferred, and is used in place of <STRONG>#include</STRONG> in 
code examples throughout OPENSTEP documentation.
<P><A name=1468></A>To reflect the fact that a class definition builds on the 
definitions of inherited classes, an interface file begins by importing the 
interface for its superclass:
<P><A name=3415></A><PRE>    #import "<EM>ItsSuperclass</EM>.h"

    @interface <EM>ClassName</EM> : <EM>ItsSuperclass </EM>
    {

	    <EM>instance variable declarations </EM>

    }

    <EM>method declarations </EM>

    @end
</PRE><A name=1469></A>This convention means that every interface file includes, 
indirectly, the interface files for all inherited classes. When a source module 
imports a class interface, it gets interfaces for the entire inheritance 
hierarchy that the class is built upon.
<P><A name=1470></A>
<H3>Referring to Other Classes</H3><A name=1471></A>An interface file declares a 
class and, by importing its superclass, implicitly contains declarations for all 
inherited classes, from NSObject on down through its superclass. If the 
interface mentions classes not in this hierarchy, it must import them 
explicitly--or, better, declare them with the <STRONG>@class</STRONG> directive:
<P><A name=3423></A><PRE>    @class Rectangle, Circle;
</PRE><A name=1472></A>This directive simply informs the compiler that 
``Rectangle'' and ``Circle'' are class names. It doesn't import their interface 
files.
<P><A name=1473></A>An interface file mentions class names when it statically 
types instance variables, return values, and arguments. For example, this 
declaration
<P><A name=3430></A><PRE>    - (void)setPrimaryColor:(NSColor *)aColor;
</PRE><A name=1474></A>mentions the NSColor class.
<P><A name=1475></A>Since declarations like this simply use the class name as a 
type and don't depend on any details of the class interface (its methods and 
instance variables), the <STRONG>@class</STRONG> directive gives the compiler 
sufficient forewarning of what to expect. However, where the interface to a 
class is actually used (instances created, messages sent), the class interface 
must be imported. Typically, an interface file uses <STRONG>@class</STRONG> to 
declare classes, and the corresponding implementation file imports their 
interfaces (since it will need to create instances of those classes or send them 
messages).
<P><A name=1476></A>The <STRONG>@class</STRONG> directive minimizes the amount 
of code seen by the compiler and linker, and is therefore the simplest way to 
give a forward declaration of a class name. Being simple, it avoids potential 
problems that may come with importing files that import still other files. For 
example, if one class declares a statically typed instance variable of another 
class, and their two interface files import each other, neither class may 
compile correctly.
<P><A name=1477></A>
<H3>The Role of the Interface</H3><A name=1478></A>The purpose of the interface 
file is to declare the new class to other source modules (and to other 
programmers). It contains all the information they need to work with the class 
(programmers might also appreciate a little documentation).
<P>
<UL><A name=1479></A>
  <LI>Through its list of method declarations, the interface file lets other 
  modules know what messages can be sent to the class object and instances of 
  the class. Every method that can be used outside the class definition is 
  declared in the interface file; methods that are internal to the class 
  implementation can be omitted. <A name=1480></A>
  <LI>It also lets the compiler know what instance variables an object contains 
  and programmers know what variables their subclasses will inherit. Although 
  instance variables are most naturally viewed as a matter of the implementation 
  of a class rather than its interface, they must nevertheless be declared in 
  the interface file. This is because the compiler must be aware of the 
  structure of an object where it's used, not just where it's defined. As a 
  programmer, however, you can generally ignore the instance variables of the 
  classes you use, except when defining a subclass. <A name=1481></A>
  <LI>Finally, the interface file also tells users how the class is connected 
  into the inheritance hierarchy and what other classes--inherited or simply 
  referred to somewhere in the class--are needed. </LI></UL><A name=1482></A>
<HR width="50%">

<CENTER><FONT size=+2>T<FONT size=+0><FONT size=+1>he<FONT size=+0> <FONT 
size=+2>I<FONT size=+0><FONT size=+1>mplementation<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1483></A>The definition of a class is structured very much like its 
declaration. It begins with an <STRONG>@implementation</STRONG> directive and 
ends with <STRONG>@end:</STRONG>
<P><A name=3437></A><PRE>    @implementation <EM>ClassName</EM> : <EM>ItsSuperclass </EM>
    {

	<I>instance variable declarations</I>

    }

    <I>method definitions</I>

    @end
</PRE><A name=1484></A>However, every implementation file must import its own 
interface. For example, <STRONG>Rectangle.m</STRONG> imports 
<STRONG>Rectangle.h</STRONG>. Because the implementation doesn't need to repeat 
any of the declarations it imports, it can safely omit:
<P>
<UL><A name=1485></A>
  <LI>The name of the superclass <A name=1486></A>
  <LI>The declarations of instance variables </LI></UL><A name=1487></A>This 
simplifies the implementation and makes it mainly devoted to method definitions:
<P><A name=3444></A><PRE>    #import "<EM>ClassName</EM>.h"

    @implementation <EM>ClassName</EM>
	<EM>method definitions</EM>
    @end
</PRE><A name=1488></A>Methods for a class are defined, like C functions, within 
a pair of braces. Before the braces, they're declared in the same manner as in 
the interface file, but without the semicolon. For example:
<P><A name=3451></A><PRE>    + alloc
    {
	. . .
    }
</PRE><A name=3477></A><PRE>    - (BOOL)isfilled
    {
	. . .
    }
</PRE><A name=3482></A><PRE>    -(void)setFilled:(BOOL) flag
    {
	. . .
    }
</PRE><A name=1489></A>Methods that take a variable number of arguments handle 
them just as a functions would:
<P><A name=3464></A><PRE>    #import <STDARG.H>

    - getGroup:group, ...
    {
	va_list  ap;
	va_start(ap, group);
	. . .
    }
</PRE><A name=1490></A>
<H3>Referring to Instance Variables</H3><A name=1491></A>By default, the 
definition of an instance method has all the instance variables of a potential 
receiving object within its scope. It can refer to them simply by name. Although 
the compiler creates the equivalent of C structures to store instance variables, 
the exact nature of the structure is hidden. You don't need either of the 
structure operators (`<STRONG>.</STRONG>' or `<STRONG>-&gt;</STRONG>') to refer 
to an object's data. For example, the following method definition refers to the 
receiver's <STRONG>tag</STRONG> instance variable:
<P><A name=3471></A><PRE>    - (void)setFilled:(BOOL)flag
    {
	filled = flag;
	. . .
    }
</PRE><A name=1492></A>Neither the receiving object nor its 
<STRONG>filled</STRONG> instance variable is declared as an argument to this 
method, yet the instance variable falls within its scope. This simplification of 
method syntax is a significant shorthand in the writing of Objective-C code.
<P><A name=1493></A>The instance variables of the receiving object are not the 
only ones that you can refer to within the implementation of a class. You can 
refer to any instance variable of any object as long as two conditions are met:
<P>
<UL><A name=1494></A>
  <LI>The instance variable must be within the scope of the class definition. 
  Normally that means the instance variable must be one that the class declares 
  or inherits. (Scope is discussed in more detail in the next section.) <A 
  name=1495></A>
  <LI>The compiler must know what kind of object the instance variable belongs 
  to. </LI></UL><A name=1496></A>When the instance variable belongs to the 
receiver (as it does in the <STRONG>setFilled:</STRONG> example above), this 
second condition is met automatically. The receiver's type is implicit but 
clear--it's the very type that the class defines.
<P><A name=1497></A>When the instance variable belongs to an object that's not 
the receiver, the object's type must be made explicit to the compiler through 
static typing. In referring to the instance variable of a statically typed 
object, the structure pointer operator (`<STRONG>-&gt;</STRONG>') is used.
<P><A name=1498></A>Suppose, for example, that the Sibling class declares a 
statically typed object, <STRONG>twin</STRONG>, as an instance variable:
<P><A name=3498></A><PRE>    @interface Sibling : NSObject
    {
	Sibling *twin;
	int gender;
	struct features *appearance;
    }
</PRE><A name=1499></A>As long as the instance variables of the statically typed 
object are within the scope of the class (as they are here because 
<STRONG>twin</STRONG> is typed to the same class), a Sibling method can set them 
directly:
<P><A name=3505></A><PRE>    - makeIdenticalTwin
    {
	if ( !twin ) {
	    twin             = [[Sibling alloc] init];
	    twin-&gt;gender     = gender;
	    twin-&gt;appearance = appearance;
	}
	return twin;
    }
</PRE><A name=1500></A>
<H3>The Scope of Instance Variables</H3><A name=1501></A>Although they're 
declared in the class interface, instance variables are more a matter of the way 
a class is implemented than of the way it's used. An object's interface lies in 
its methods, not in its internal data structures.
<P><A name=1502></A>Often there's a one-to-one correspondence between a method 
and an instance variable, as in the following example:
<P><A name=3512></A><PRE>    - (BOOL)isFilled
    {
	return filled;
    }
</PRE><A name=1503></A>But this need not be the case. Some methods might return 
information not stored in instance variables, and some instance variables might 
store information that an object is unwilling to reveal.
<P><A name=1504></A>As a class is revised from time to time, the choice of 
instance variables may change, even though the methods it declares remain the 
same. As long as messages are the vehicle for interacting with instances of the 
class, these changes won't really affect its interface.
<P><A name=1505></A>To enforce the ability of an object to hide its data, the 
compiler limits the scope of instance variables--that is, limits their 
visibility within the program. But to provide flexibility, it also lets you 
explicitly set the scope at three different levels. Each level is marked by a 
compiler directive:
<P><A name=1506></A><A name=1507></A><A name=3748></A><A name=1508></A><A 
name=3749></A><A name=1509></A><A name=3750></A><A name=1510></A>
<TABLE cellSpacing=2 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD align=left width="20%"><FONT size=+1><B>Directive</B></FONT> </TD>
    <TD align=left><FONT size=+1><B>Definition</B></FONT></TD></TR>
  <TR>
    <P></P></TR>
  <TR>
    <TD align=left><B>@private</B> </TD>
    <TD align=left>The instance variable is accessible only within the class 
      that declares it. </TD></TR>
  <TR>
    <TD align=left><B>@protected</B> </TD>
    <TD align=left>The instance variable is accessible within the class that 
      declares it and within classes that inherit it. </TD></TR>
  <TR>
    <TD align=left><B>@public</B> </TD>
    <TD align=left>The instance variable is accessible everywhere. 
  </TD></TR></TBODY></TABLE>
<P>This is illustrated in the following figure.
<P><A name=1511></A>
<P><IMG hspace=10 src="" align=left> <A name=1512></A>A directive applies to all 
the instance variables listed after it, up to the next directive or the end of 
the list. In the following example, the <STRONG>age</STRONG> and 
<STRONG>evaluation</STRONG> instance variables are private, 
<STRONG>name</STRONG>, <STRONG>job</STRONG>, and <STRONG>wage</STRONG> are 
protected, and <STRONG>boss</STRONG> is public.
<P><A name=3520></A><BR clear=all>
<P><PRE>    @interface Worker : NSObject
    {
	char *name;
    @private
	int age;
	char *evaluation;
    @protected
	id job;
	float wage;
    @public
	id boss;
    }
</PRE><A name=1513></A>By default, all unmarked instance variables (like 
<STRONG>name</STRONG> above) are <STRONG>@protected</STRONG>.
<P><A name=598></A>All instance variable that a class declares, no matter how 
they're marked, are within the scope of the class definition. For example, a 
class that declares a <STRONG>job</STRONG> instance variable, such as the Worker 
class shown above, can refer to it in a method definition: 
<P><A name=3527></A><PRE>    - promoteTo:newPosition
    {
	id old = job;

	job = newPosition;
	return old;
    }
</PRE><A name=688></A>Obviously, if a class couldn't access its own instance 
variables, the instance variables would be of no use whatsoever.
<P><A name=1514></A>Normally, a class also has access to the instance variables 
it inherits. The ability to refer to an instance variable is usually inherited 
along with the variable. It makes sense for classes to have their entire data 
structures within their scope, especially if you think of a class definition as 
merely an elaboration of the classes it inherits from. The 
<STRONG>promoteTo:</STRONG> method illustrated above could just as well have 
been defined in any class that inherits the <STRONG>job</STRONG> instance 
variable from the Worker class.
<P><A name=1515></A>However, there are reasons why you might want to restrict 
inheriting classes from accessing an instance variable:
<P>
<UL><A name=1516></A>
  <LI>Once a subclass accesses an inherited instance variable, the class that 
  declares the variable is tied to that part of its implementation. In later 
  versions, it can't eliminate the variable or alter the role it plays without 
  inadvertently breaking the subclass. <A name=1517></A>
  <LI>Moreover, if a subclass accesses an inherited instance variable and alters 
  its value, it may inadvertently introduce bugs in the class that declares the 
  variable, especially if the variable is involved in class-internal 
  dependencies. </LI></UL><A name=1518></A>To limit an instance variable's scope 
to just the class that declares it, you must mark it <STRONG>@private</STRONG>.
<P><A name=1519></A>At the other extreme, marking a variable 
<STRONG>@public</STRONG> makes it generally available, even outside of class 
definitions that inherit or declare the variable. Normally, to get information 
stored in an instance variable, other modules must send a message requesting it. 
However, a public instance variable can be accessed anywhere as if it were a 
field in a C structure.
<P><A name=3534></A><PRE>    Worker *ceo = [[Worker alloc] init];

    ceo-&gt;boss = nil;
</PRE><A name=1520></A>Note that the object must be statically typed.
<P><A name=1521></A>Marking instance variables @public defeats the ability of an 
object to hide its data. It runs counter to a fundamental principle of 
object-oriented programming--the encapsulation of data within objects where it's 
protected from view and inadvertent error. Public instance variables should 
therefore be avoided except in extraordinary cases.
<P><A name=1522></A>
<HR width="75%">

<CENTER><FONT size=+3>H<FONT size=+0><FONT size=+2>ow<FONT size=+0> <FONT 
size=+3>M<FONT size=+0><FONT size=+2>essaging<FONT size=+0> <FONT size=+3>W<FONT 
size=+0><FONT size=+2>orks<FONT size=+0> </CENTER>
<HR width="75%">

<P><A name=1523></A>In Objective-C, messages aren't bound to method 
implementations until run time. The compiler converts a message expression,
<P><A name=3541></A><PRE>    [<I>receiver message</I>]
</PRE><A name=1524></A>into a call on a messaging function, 
<STRONG>objc_msgSend()</STRONG>. This function takes the receiver and the name 
of the method mentioned in the message--that is, the method selector--as its two 
principal arguments:
<P><A name=3549></A><PRE>    objc_msgSend(<I>receiver</I>, <I>selector</I>)
</PRE><A name=1525></A>Any arguments passed in the message are also handed to 
<STRONG>objc_msgSend():</STRONG>
<P><A name=3556></A><PRE>    objc_msgSend(<I>receiver</I>, <I>selector</I>, 
			<I>arg1</I>, <I>arg2</I>, . . .)
</PRE><A name=1526></A>The messaging function does everything necessary for 
dynamic binding:
<P>
<UL><A name=1527></A>
  <LI>It first finds the procedure (method implementation) that the selector 
  refers to. Since the same method can be implemented differently by different 
  classes, the precise procedure that it finds depends on the class of the 
  receiver. <A name=1528></A>
  <LI>It then calls the procedure, passing it the receiving object (a pointer to 
  its data), along with any arguments that were specified for the method. <A 
  name=1529></A>
  <LI>Finally, it passes on the return value of the procedure as its own return 
  value. <A name=1530></A>Note: The compiler generates calls to the messaging 
  function. You should never call it directly in the code you write. </LI></UL><A 
name=1531></A>The key to messaging lies in the structures that the compiler 
builds for each class and object. Every class structure includes these two 
essential elements:
<P>
<UL><A name=1532></A>
  <LI>A pointer to the superclass. <A name=1533></A>
  <LI>A class <EM>dispatch table</EM>. This table has entries that associate 
  method selectors with the class-specific addresses of the methods they 
  identify. The selector for the <STRONG>setOrigin::</STRONG> method is 
  associated with the address of (the procedure that implements) 
  <STRONG>setOrigin::</STRONG>, the selector for the <STRONG>display</STRONG> 
  method is associated with <STRONG>display</STRONG>'s address, and so on. 
</LI></UL><A name=1534></A>When a new object is created, memory for it is 
allocated and its instance variables are initialized. First among the object's 
variables is a pointer to its class structure. This pointer, called 
<STRONG>isa</STRONG>, gives the object access to its class and, through the 
class, to all the classes it inherits from.
<P><A name=1535></A>These elements of class and object structure are illustrated 
in the following figure.
<P><A name=1536></A>
<P><IMG hspace=10 src="" align=left> <A name=1537></A>When a message is sent to 
an object, the messaging function follows the object's <STRONG>isa</STRONG> 
pointer to the class structure, where it looks up the method selector in the 
dispatch table. If it can't find the selector there, 
<STRONG>objc_msgSend()</STRONG> follows the pointer to the superclass and tries 
to find the selector in its dispatch table. Successive failures cause 
<STRONG>objc_msgSend()</STRONG> to climb the class hierarchy until it reaches 
the NSObject class. Once it locates the selector, it calls the method entered in 
the table and passes it the receiving object's data structure.
<P><A name=1538></A>This is the way that method implementations are chosen at 
run time--or, in the jargon of object-oriented programming, that methods are 
dynamically bound to messages.
<P><A name=1539></A>To speed the messaging process, the run-time system caches 
the selectors and addresses of methods as they are used. There's a separate 
cache for each class, and it can contain selectors for inherited methods as well 
as for methods defined in the class. Before searching the dispatch tables, the 
messaging routine first checks the cache of the receiving object's class (on the 
theory that a method that was used once may likely be used again). If the method 
selector is in the cache, messaging is only slightly slower than a function 
call. Once a program has been running long enough to ``warm up'' its caches, 
almost all the messages it sends will find a cached method. Caches grow 
dynamically to accommodate new messages as the program runs.
<P><A name=1540></A>
<HR width="50%">

<CENTER><FONT size=+2>S<FONT size=+0><FONT size=+1>electors<FONT size=+0> 
</CENTER>
<HR width="50%">

<P><A name=1541></A>For efficiency, full ASCII names are not used as method 
selectors in compiled code. Instead, the compiler writes each method name into a 
table, then pairs the name with a unique identifier that will represent the 
method at run time. The run-time system makes sure each identifier is unique: No 
two selectors are the same, and all methods with the same name have the same 
selector. Compiled selectors are assigned to a special type, SEL, to distinguish 
them from other data. Valid selectors are never 0.
<P><A name=1542></A>A compiled selector contains fields of coded information 
that aid run-time messaging. You should therefore let the system assign SEL 
identifiers to methods; it won't work to assign them arbitrarily yourself.
<P><A name=1543></A>The <STRONG>@selector()</STRONG> directive lets Objective-C 
source code refer to the compiled selector, rather than to the full method name. 
Here the selector for <STRONG>setWidth:height::</STRONG> is assigned to the 
<STRONG>setWidthHeight</STRONG> variable:
<P><A name=3564></A><PRE>    SEL  setWidthHeight; 
    setWidthHeight = @selector(setWidth:height:);
</PRE><A name=1544></A>It's most efficient to assign values to SEL variables at 
compile time with the <STRONG>@selector()</STRONG> directive. However, in some 
cases, a program may need to convert a character string to a selector at run 
time. This can be done with the <STRONG>sel_getUid()</STRONG> function:
<P><A name=3571></A><PRE>    setWidthHeight = sel_getUid(aBuffer);
</PRE><A name=1545></A>Conversion in the opposite direction is also possible. 
The <STRONG>sel_getName()</STRONG> function returns a method name for a 
selector:
<P><A name=3578></A><PRE>    char *method;
    method = sel_getName(setWidthHeight);
</PRE><A name=1546></A>These and other run-time functions are described in the 
OPENSTEP framework reference documentation.
<P><A name=1547></A>
<H3>Methods and Selectors</H3><A name=1548></A>Compiled selectors identify 
method names, not method implementations. Rectangle's <STRONG>display</STRONG> 
method, for example, will have the same selector as <STRONG>display</STRONG> 
methods defined in other classes. This is essential for polymorphism and dynamic 
binding; it lets you send the same message to receivers belonging to different 
classes. If there were one selector per method implementation, a message would 
be no different than a function call.
<P><A name=1549></A>A class method and an instance method with the same name are 
assigned the same selector. However, because of their different domains, there's 
no confusion between the two. A class could define a <STRONG>display</STRONG> 
class method in addition to a <STRONG>display</STRONG> instance method.
<P><A name=1550></A>
<H3>Method Return and Argument Types</H3><A name=1551></A>The messaging routine 
has access to method implementations only through selectors, so it treats all 
methods with the same selector alike. It discovers the return type of a method, 
and the data types of its arguments, from the selector. Therefore, except for 
messages sent to statically typed receivers, dynamic binding requires all 
implementations of identically named methods to have the same return type and 
the same argument types. (Statically typed receivers are an exception to this 
rule, since the compiler can learn about the method implementation from the 
class type.)
<P><A name=1552></A>Although identically named class methods and instance 
methods are represented by the same selector, they can have different argument 
and return types. 
<P><A name=1553></A>
<H3>Varying the Message at Run Time</H3><A name=1554></A>The 
<STRONG>perform:</STRONG>, <STRONG>perform:withObject:</STRONG>, and 
<STRONG>perform:withObject:withObject:</STRONG> methods, defined in the NSObject 
protocol, take SEL identifiers as their initial arguments. All three methods map 
directly into the messaging function. For example,
<P><A name=3583></A>[friend perform:@selector(gossipAbout:) 
withObject:aNeighbor];
<P><A name=1555></A>is equivalent to:
<P><A name=3589></A>[friend gossipAbout:aNeighbor];
<P><A name=1556></A>These methods make it possible to vary a message at run 
time, just as it's possible to vary the object that receives the message. 
Variable names can be used in both halves of a message expression:
<P><A name=3598></A><PRE>    id   helper  = getTheReceiver();
    SEL  request = getTheSelector();

    [helper perform:request];
</PRE><A name=1557></A>In this example, the receiver (<STRONG>helper</STRONG>) 
is chosen at run time (by the fictitious <STRONG>getTheReceiver()</STRONG> 
function), and the method the receiver is asked to perform 
(<STRONG>request</STRONG>) is also determined at run time (by the equally 
fictitious <STRONG>getTheSelector()</STRONG> function).
<P><A name=1558></A>Note: <STRONG>perform:</STRONG> and its companion methods 
return an <STRONG>id</STRONG>. If the method that's performed returns a 
different type, it should be cast to the proper type. (However, casting won't 
work for all types; the method should return a pointer or a type compatible with 
a pointer.) <A name=1559></A>
<H3>The Target-Action Paradigm</H3><A name=1560></A>In its treatment of 
user-interface controls, the OPENSTEP Application Kit makes good use of the 
ability vary both the receiver and the message.
<P><A name=1561></A>Controls are graphical devices that can be used to give 
instructions to an application. Most resemble real-world control devices such as 
buttons, switches, knobs, text fields, dials, menu items, and the like. In 
software, these devices stand between the application and the user. They 
interpret events coming from hardware devices like the keyboard and mouse and 
translate them into application-specific instructions. For example, a button 
labeled ``Find'' would translate a mouse click into an instruction for the 
application to start searching for something.
<P><A name=1562></A>The Application Kit defines a framework for creating control 
devices and defines a few ``off-the-shelf'' devices of its own. For example, the 
NSButtonCell class defines an object that you can assign to an NSMatrix and 
initialize with a size, a label, a picture, a font, and a keyboard alternative. 
When the user clicks the button (or uses the keyboard alternative), the 
NSButtonCell sends a message instructing the application to do something. To do 
this, an NSButtonCell must be initialized not just with an image, a size, and a 
label, but with directions on what message to send and who to send it to. 
Accordingly, an NSButtonCell can be initialized for an <EM>action message</EM>, 
the method selector it should use in the message it sends, and a target, the 
object that should receive the message.
<P><A name=3605></A><PRE>    [myButtonCell setAction:@selector(reapTheWind:)];
    [myButtonCell setTarget:anObject];
</PRE><A name=1563></A>The NSButtonCell sends the message using NSObject's 
<STRONG>perform:withObject:</STRONG> method. All action messages take a single 
argument, the id of the control device sending the message.
<P><A name=1564></A>If Objective-C didn't allow the message to be varied, all 
NSButtonCells would have to send the same message; the name of the method would 
be frozen in the NSButtonCell source code. Instead of simply implementing a 
mechanism for translating user actions into action messages, NSButtonCells and 
other controls would have to constrain the content of the message. This would 
make it difficult for any object to respond to more than one NSButtonCell. There 
would either have to be one target for each button, or the target object would 
have to discover which button the message came from and act accordingly. Each 
time you rearranged the user interface, you'd also have to re-implement the 
method that responds to the action message. This would be an unnecessary 
complication that Objective-C happily avoids.
<P><A name=1565></A>
<H3>Avoiding Messaging Errors</H3><A name=1566></A>If an object receives a 
message to perform a method that isn't in its repertoire, an error results. It's 
the same sort of error as calling a nonexistent function. But because messaging 
occurs at run time, the error often won't be evident until the program executes.
<P><A name=1567></A>It's relatively easy to avoid this error when the message 
selector is constant and the class of the receiving object is known. As you're 
programming, you can check to be sure that the receiver is able to respond. If 
the receiver is statically typed, the compiler will check for you.
<P><A name=1568></A>However, if the message selector or the class of the 
receiver varies, it may be necessary to postpone this check until run time. The 
<STRONG>respondsToSelector:</STRONG> method, defined in the NSObject class, 
determines whether a potential receiver can respond to a potential message. It 
takes the method selector as an argument, and returns whether the receiver has 
access to a method matching the selector:
<P><A name=3612></A><PRE>    if ( [anObject respondsToSelector:@selector(setOrigin::)] ) 
	[anObject setOrigin:0.0 :0.0]; 
    else 
	fprintf(stderr, "%s can't be placed\n", [anObject name]);
</PRE><A name=1569></A>The <STRONG>respondsToSelector:</STRONG> test is 
especially important when sending messages to objects that you don't have 
control over at compile time. For example, if you write code that sends a 
message to an object represented by a variable that others can set, you should 
check to be sure the receiver implements a method that can respond to the 
message.
<P><A name=1570></A>Note: An object can also arrange to have messages it 
receives forwarded to other objects, if it can't respond to them directly 
itself. In that case, it will appear that the object can't handle the message, 
even though it responds to it indirectly by assigning it to another object. 
Forwarding is discussed in <A 
href="http://toodarkpark.org/computers/objc/runtime.html#">Chapter 4</A>, 
``<STRONG><A href="http://toodarkpark.org/computers/objc/runtime.html#">The 
Run-Time System</A></STRONG>.'' <PRE></PRE><A name=1571></A>
<HR width="50%">

<CENTER><FONT size=+2>H<FONT size=+0><FONT size=+1>idden<FONT size=+0> <FONT 
size=+2>A<FONT size=+0><FONT size=+1>rguments<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1572></A>When the messaging function finds the procedure that 
implements a method, it calls the procedure and passes it all the arguments in 
the message. It also passes the procedure two hidden arguments:
<P>
<UL><A name=1573></A>
  <LI>The receiving object. <A name=1574></A>
  <LI>The selector for the method. </LI></UL><A name=1575></A>These arguments give 
every method implementation explicit information about the two halves of the 
message expression that invoked it. They're said to be ``hidden'' because they 
aren't declared in the source code that defines the method. They're inserted 
into the implementation when the code is compiled.
<P><A name=1576></A>Although these arguments aren't explicitly declared, source 
code can still refer to them (just as it can refer to the receiving object's 
instance variables). A method refers to the receiving object as 
<STRONG>self</STRONG>, and to its own selector as <STRONG>_cmd</STRONG>. In the 
example below, <STRONG>_cmd</STRONG> refers to the selector for the 
<STRONG>strange</STRONG> method and <STRONG>self</STRONG> to the object that 
receives a <STRONG>strange</STRONG> message.
<P><A name=3619></A><PRE>    - strange
    {
	id  target = getTheReceiver();
	SEL action = getTheMethod();

	if ( target == self || action == _cmd )
	    return nil;
	return [target perform:action];
    }
</PRE><A name=1577></A><STRONG>self</STRONG> is the more useful of the two 
arguments. It is, in fact, the way the receiving object's instance variables are 
made available to the method definition.
<P><A name=1578></A>Some methods that have no other meaningful return value 
return <STRONG>self</STRONG>, rather than <STRONG>void</STRONG>. This enables 
such messages to be nested in source code. For example, if 
<STRONG>setWidthHeight:</STRONG>, <STRONG>setFilled:</STRONG>, and 
<STRONG>setFillColor:</STRONG> all returned <STRONG>self</STRONG>, you could 
write code like the following:
<P><A name=3626></A><PRE>    [[[myRect setWidth:10.0 height:5.0] setFilled:YES] 
			setFillColor:Green];
</PRE><A name=1579></A><STRONG>self</STRONG> is discussed in more detail in the 
next section.
<P><A name=1580></A>
<HR width="50%">

<CENTER><FONT size=+2>M<FONT size=+0><FONT size=+1>essages to<FONT size=+0> 
<FONT size=+2>S<FONT size=+0><FONT size=+1>elf and<FONT size=+0> <FONT 
size=+2>S<FONT size=+0><FONT size=+1>uper<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1581></A>Objective-C provides two terms that can be used within a 
method definition to refer to the object that performs the 
method--<STRONG>self</STRONG> and <STRONG>super</STRONG>.
<P><A name=1582></A>Suppose, for example, that you define a 
<STRONG>reposition</STRONG> method that needs to change the coordinates of 
whatever object it acts on. It can invoke the <STRONG>setOrigin::</STRONG> 
method to make the change. All it needs to do is send a 
<STRONG>setOrigin::</STRONG> message to the very same object that the 
<STRONG>reposition</STRONG> message itself was sent to. When you're writing the 
<STRONG>reposition</STRONG> code, you can refer to that object as either 
<STRONG>self</STRONG> or <STRONG>super</STRONG>. The <STRONG>reposition</STRONG> 
method could read either:
<P><A name=3646></A><PRE>    - reposition
    {
	. . .
	[self setOrigin:someX :someY]; 
	. . .  
    }
</PRE><A name=1583></A>or:
<P><A name=3655></A><PRE>    - reposition
    {
	. . .
	[super setOrigin:someX :someY]; 
	. . .  
    }
</PRE><A name=1584></A>Here <STRONG>self</STRONG> and <STRONG>super</STRONG> 
both refer to the object receiving a <STRONG>reposition</STRONG> message, 
whatever object that may happen to be. The two terms are quite different, 
however. <STRONG>self</STRONG> is one of the hidden arguments that the messaging 
routine passes to every method; it's a local variable that can be used freely 
within a method implementation, just as the names of instance variables can be. 
<STRONG>super</STRONG> is a term that substitutes for <STRONG>self</STRONG> only 
as the receiver in a message expression. As receivers, the two terms differ 
principally in how they affect the messaging process:
<P>
<UL><A name=1585></A>
  <LI><STRONG>self</STRONG> searches for the method implementation in the usual 
  manner, starting in the dispatch table of the receiving object's class. In the 
  example above, it would begin with the class of the object receiving the 
  <STRONG>reposition</STRONG> message. <A name=1586></A>
  <LI><STRONG>super</STRONG> starts the search for the method implementation in 
  a very different place. It begins in the superclass of the class that defines 
  the method where <STRONG>super</STRONG> appears. In the example above, it 
  would begin with the superclass of the class where <STRONG>reposition</STRONG> 
  is defined. </LI></UL><A name=1587></A>Wherever <STRONG>super</STRONG> receives 
a message, the compiler substitutes another messaging routine for 
<STRONG>objc_msgSend()</STRONG>. The substitute routine looks directly to the 
superclass of the defining class--that is, to the superclass of the class 
sending the message to <STRONG>super</STRONG>--rather than to the class of the 
object receiving the message.
<P><A name=1588></A>
<H3>An Example</H3><A name=1589></A>The difference between <STRONG>self</STRONG> 
and <STRONG>super</STRONG> becomes clear in a hierarchy of three classes. 
Suppose, for example, that we create an object belonging to a class called Low. 
Low's superclass is Mid; Mid's superclass is High. All three classes define a 
method called <STRONG>negotiate</STRONG>, which they use for a variety of 
purposes. In addition, Mid defines an ambitious method called 
<STRONG>makeLastingPeace</STRONG>, which also has need of the 
<STRONG>negotiate</STRONG> method. This is illustrated in the following figure:
<P><A name=1590></A>
<P><IMG hspace=10 src="" align=left> <A name=1591></A>We now send a message to 
our Low object to perform the <STRONG>makeLastingPeace</STRONG> method, and 
<STRONG>makeLastingPeace</STRONG>, in turn, sends a <STRONG>negotiate</STRONG> 
message to the same Low object. If source code calls this object 
<STRONG>self</STRONG>,
<P><A name=3667></A><PRE>    - makeLastingPeace
    {
	[self negotiate]; 
	. . .
    }
</PRE><A name=1592></A>the messaging routine will find the version of 
<STRONG>negotiate</STRONG> defined in Low, <STRONG>self</STRONG>'s class. 
However, if source code calls this object <STRONG>super</STRONG>,
<P><A name=3674></A><BR clear=all><PRE>    - makeLastingPeace
    {
	[super negotiate]; 
	. . .  
    }
</PRE><A name=1593></A>the messaging routine will find the version of 
<STRONG>negotiate</STRONG> defined in High. It ignores the receiving object's 
class (Low) and skips to the superclass of Mid, since Mid is where 
<STRONG>makeLastingPeace</STRONG> is defined. Neither message finds Mid's 
version of <STRONG>negotiate</STRONG>.
<P><A name=1594></A>As this example illustrates, <STRONG>super</STRONG> provides 
a way to bypass a method that overrides another method. Here it enabled 
<STRONG>makeLastingPeace</STRONG> to avoid the Mid version of 
<STRONG>negotiate</STRONG> that redefined the original High version.
<P><A name=1595></A>Not being able to reach Mid's version of 
<STRONG>negotiate</STRONG> may seem like a flaw, but, under the circumstances, 
it's right to avoid it:
<P>
<UL><A name=1596></A>
  <LI>The author of the Low class intentionally overrode Mid's version of 
  <STRONG>negotiate</STRONG> so that instances of the Low class (and its 
  subclasses) would invoke the redefined version of the method instead. The 
  designer of Low didn't want Low objects to perform the inherited method. <A 
  name=1597></A>
  <LI>In sending the message to <STRONG>super</STRONG>, the author of Mid's 
  <STRONG>makeLastingPeace</STRONG> method intentionally skipped over Mid's 
  version of <STRONG>negotiate</STRONG> (and over any versions that might be 
  defined in classes like Low that inherit from Mid) to perform the version 
  defined in the High class. Mid's designer wanted to use the High version of 
  <STRONG>negotiate</STRONG> and no other. </LI></UL><A name=1598></A>Mid's 
version of <STRONG>negotiate</STRONG> could still be used, but it would take a 
direct message to a Mid instance to do it.
<P><A name=1599></A>
<H3>Using <STRONG>super</STRONG></H3><A name=1600></A>Messages to 
<STRONG>super</STRONG> allow method implementations to be distributed over more 
than one class. You can override an existing method to modify or add to it, and 
still incorporate the original method in the modification:
<P><A name=3685></A><PRE>    - negotiate
    {
	. . .  
	return [super negotiate]; 
    }
</PRE><A name=1601></A>For some tasks, each class in the inheritance hierarchy 
can implement a method that does part of the job, and pass the message on to 
<STRONG>super</STRONG> for the rest. The <STRONG>init</STRONG> method, which 
initializes a newly allocated instance, is designed to work like this. Each init 
method has responsibility for initializing the instance variables defined in its 
class. But before doing so, it sends an <STRONG>init</STRONG> message to 
<STRONG>super</STRONG> to have the classes it inherits from initialize their 
instance variables. Each version of <STRONG>init</STRONG> follows this same 
procedure, so classes initialize their instance variables in the order of 
inheritance:
<P><A name=3692></A><PRE>    - (id)init
    {
	[super init];
	. . .  
    }
</PRE><A name=1602></A>It's also possible to concentrate core functionality in 
one method defined in a superclass, and have subclasses incorporate the method 
through messages to <STRONG>super</STRONG>. For example, every class method that 
creates a new instance must allocate storage for the new object and initialize 
its isa pointer to the class structure. This is typically left to the 
<STRONG>alloc</STRONG> and <STRONG>allocWithZone:</STRONG> methods defined in 
the NSObject class. If another class overrides these methods for any reason (a 
rare case), it can still get the basic functionality by sending a message to 
<STRONG>super</STRONG>.
<P><A name=1603></A>
<H3>Redefining <STRONG>self</STRONG></H3><A name=1604></A><STRONG>super</STRONG> 
is simply a flag to the compiler telling it where to begin searching for the 
method to perform; it's used only as the receiver of a message. But 
<STRONG>self</STRONG> is a variable name that can be used in any number of ways, 
even assigned a new value.
<P><A name=1605></A>There's a tendency to do just that in definitions of class 
methods. Class methods are often concerned, not with the class object, but with 
instances of the class. For example, a method might combine allocation and 
initialization of an instance:
<P><A name=3699></A><PRE>    + (id)newRect
    {
	return [[self alloc] init];
    }
</PRE><A name=1606></A>In such a method, it's tempting to send messages to the 
instance and to call the instance <STRONG>self</STRONG>, just as in an instance 
method. But that would be an error. <STRONG>self</STRONG> and 
<STRONG>super</STRONG> both refer to the receiving object--the object that gets 
a message telling it to perform the method. Inside an instance method, 
<STRONG>self</STRONG> refers to the instance; but inside a class method, 
<STRONG>self</STRONG> refers to the class object.
<P><A name=1607></A>Before a class method can send a message telling 
<STRONG>self</STRONG> to perform an instance method, it must redefine 
<STRONG>self</STRONG> to be the instance:
<P><A name=3706></A><PRE>    + (id)newRectofColor:(NSColor *)aColor
    {
	self = [[self alloc] init];
	[self setPrimaryColor:aColor];
	return self;
    }
</PRE><A name=1608></A>The method shown above is a class method, so, initially, 
<STRONG>self</STRONG> refers to the class object. It's as the class object that 
<STRONG>self</STRONG> receives the <STRONG>alloc</STRONG> message. 
<STRONG>self</STRONG> is then redefined to be the instance that 
<STRONG>alloc</STRONG> returns and <STRONG>init</STRONG> initializes. It's as 
the new instance that it receives the <STRONG>setPrimaryColor:</STRONG> message.
<P><A name=1609></A>To avoid confusion, it's usually better to use a variable 
other than <STRONG>self</STRONG> to refer to an instance inside a class method:
<P><A name=3713></A><PRE>    + (id)newRectofColor:(NSColor *)aColor
    {
	id newInstance = [[self alloc] init];

	[newInstance setPrimaryColor:aColor];
	return newInstance;
    }
</PRE><A name=1610></A>Note: In these examples, the class method sends messages 
(<STRONG>init</STRONG> and <STRONG>setPrimaryColor:</STRONG>) to initialize the 
instance. It doesn't assign a new value directly to an instance variable as an 
instance method might have done: <A name=3720></A><PRE>    linePattern  = aPattern;
    primaryColor = aColor;
</PRE><A name=1611></A>Only instance variables of the receiver can be directly 
set this way. Since the receiver for a class method (the class object) has no 
instance variables, this syntax can't be used. However, if 
<STRONG>newInstance</STRONG> had been statically typed, something similar would 
have been possible:
<P><A name=3725></A>newInstance-&gt;linePattern = aPattern
<P><A name=1612></A>See ``<A 
href="http://toodarkpark.org/computers/objc/coreobjc.html#1490">Referring to 
Instance Variables</A>,'' earlier in this chapter, for more on when this syntax 
is permitted.
<P><BR><A href="http://toodarkpark.org/computers/objc/oop.html"><IMG 
src="The Objective-C Language_arquivos/DocsLeftArrow.gif"></A> <A 
href="http://toodarkpark.org/computers/objc/objctoc.html"><IMG 
src="The Objective-C Language_arquivos/DocsContents.gif"></A> <A 
href="http://toodarkpark.org/computers/objc/moreobjc.html"><IMG 
src="The Objective-C Language_arquivos/DocsRightArrow.gif"></A> 
<HR>
<FONT size=-1>Last Modified: 01:17am , January 19, 1996 
<CENTER>
<HR>
<A href="http://www.next.com/HotNews/">Hot News</A> | <A 
href="http://www.next.com/OpenStep/">OpenStep</A> | <A 
href="http://www.next.com/WebObjects/">WebObjects</A> | <A 
href="http://www.next.com/Services/">Services</A> | <A 
href="http://www.next.com/BuyNow/">Buy Now</A> | <A 
href="http://www.next.com/NeXTanswers/">NeXTanswers</A> | <A 
href="http://www.next.com/Search/">Search</A> | <A 
href="http://www.next.com/AboutNeXT/">About NeXT</A> 
<HR>
</CENTER>NeXT sales and product information inquiries? <A 
href="http://www.next.com/AboutNeXT/Feedback.html">Click here</A><BR><A 
href="http://www.next.com/Legal/">Copyright</A> 1996 <A 
href="http://www.next.com/">NeXT Software, Inc.</A> <A 
href="http://www.next.com/Legal/">Proprietary Notices.</A> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></BODY></HTML>
