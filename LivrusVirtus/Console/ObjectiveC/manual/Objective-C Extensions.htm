<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0051)http://toodarkpark.org/computers/objc/moreobjc.html -->
<HTML><HEAD><TITLE>Objective-C Extensions</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2800.1458" name=GENERATOR></HEAD>
<BODY vLink=#8b4500 bgColor=#e0e0e0><A 
href="http://toodarkpark.org/computers/objc/coreobjc.html"><IMG 
src="Objective-C Extensions_arquivos/DocsLeftArrow.gif"></A> <A 
href="http://toodarkpark.org/computers/objc/objctoc.html"><IMG 
src="Objective-C Extensions_arquivos/DocsContents.gif"></A> <A 
href="http://toodarkpark.org/computers/objc/runtime.html"><IMG 
src="Objective-C Extensions_arquivos/DocsRightArrow.gif"></A> 
<P><A name=540></A><A name=623></A><A name=698></A>
<P><A name=682></A><I><FONT size=+3>C</FONT><FONT size=+2>hapter 3</FONT> </I>
<CENTER><FONT size=+5><B>T</B><FONT size=+0><FONT size=+4><B>he</B><FONT 
size=+0> <FONT size=+5><B>O</B><FONT size=+0><FONT 
size=+4><B>bjective-C</B><FONT size=+0> <FONT size=+5><B>E</B><FONT 
size=+0><FONT size=+4><B>xtensions</B><FONT size=+0> </CENTER>
<HR>

<P><A name=305></A>The preceding chapter has all you need to know about 
Objective-C to define classes and design programs in the language. It covers 
basic Objective-C syntax and explains the messaging process in detail.
<P><A name=752></A>Class definitions are at the heart of object-oriented 
programming, but they're not the only mechanism for structuring object 
definitions in Objective-C. This chapter discusses two other ways of declaring 
methods and associating them with a class:
<P>
<UL><A name=753></A>
  <LI>Categories can compartmentalize a class definition or extend an existing 
  one. <A name=754></A>
  <LI>Protocols declare methods that can be implemented by any class. </LI></UL><A 
name=755></A>The chapter also explains how static typing works and takes up some 
lesser used features of Objective-C, including ways to temporarily overcome its 
inherent dynamism.
<P><A name=756></A>
<HR width="75%">

<CENTER><FONT size=+3>C<FONT size=+0><FONT size=+2>ategories<FONT size=+0> 
</CENTER>
<HR width="75%">

<P><A name=757></A>You can add methods to a class by declaring them in an 
interface file under a category name and defining them in an implementation file 
under the same name. The category name indicates that the methods are additions 
to a class declared elsewhere, not a new class.
<P><A name=758></A>A category can be an alternative to a subclass. Rather than 
define a subclass to extend an existing class, through a category you can add 
methods to the class directly. For example, you could add categories to NSArray 
and other OPENSTEP classes. As in the case of a subclass, you don't need source 
code for the class you're extending.
<P><A name=759></A>The methods the category adds become part of the class type. 
For example, methods added to the NSArray class in a category will be among the 
methods the compiler will expect an NSArray instance to have in its repertoire. 
Methods added to the NSArray class in a subclass would not be included in the 
NSArray type. (This matters only for statically typed objects, since static 
typing is the only way the compiler can know an object's class.)
<P><A name=760></A>Category methods can do anything that methods defined in the 
class proper can do. At run time, there's no difference. The methods the 
category adds to the class are inherited by all the class's subclasses, just 
like other methods.
<P><A name=761></A>
<HR width="50%">

<CENTER><FONT size=+2>A<FONT size=+0><FONT size=+1>dding to a<FONT size=+0> 
<FONT size=+2>C<FONT size=+0><FONT size=+1>lass<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=762></A>The declaration of a category interface looks very much like 
a class interface declaration--except the category name is listed within 
parentheses after the class name and the superclass isn't mentioned. The 
category must import the interface file for the class it extends:
<P><A name=2862></A><PRE>#import "<EM>ClassName</EM>.h"<BR>
<BR>
@interface <EM>ClassName</EM> ( <EM>CategoryName</EM> )<BR>
<EM>method declarations<BR>
</EM>@end
</PRE><A name=764></A>The implementation, as usual, imports its own interface. 
Assuming that interface and implementation files are named after the category, a 
category implementation looks like this:
<P><A name=2869></A><PRE>#import "<EM>CategoryName</EM>.h"<BR>
<BR>
@implementation <EM>ClassName</EM> ( <EM>CategoryName</EM> )<BR>
<EM>method definitions<BR>
</EM>@end
</PRE><A name=767></A>Note that a category can't declare any new instance 
variables for the class; it includes only methods. However, all instance 
variables within the scope of the class are also within the scope of the 
category. That includes all instance variables declared by the class, even ones 
declared <STRONG>@private</STRONG>.
<P><A name=769></A>declared in the class interface. However, it cannot reliably 
override methods declared in another category of the same class. A category is 
not a substitute for a subclass. It's best if categories don't attempt to 
redefine methods the class defines elsewhere; a class shouldn't define the same 
method more than once.
<P><A name=770></A>Note: When a category overrides an inherited method, the new 
version can, as usual, incorporate the inherited version through a message to 
<STRONG>super</STRONG>. But there's no way for a category method to incorporate 
a method with the same name defined for the same class.
<P><A name=771></A>
<HR width="50%">

<CENTER><FONT size=+2>H<FONT size=+0><FONT size=+1>ow<FONT size=+0> <FONT 
size=+2>C<FONT size=+0><FONT size=+1>atergories are used<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=772></A>Categories can be used to extend classes defined by other 
implementors--for example, you can add methods to the classes defined in the 
OPENSTEP frameworks. The added methods will be inherited by subclasses and will 
be indistinguishable at run time from the original methods of the class.
<P><A name=773></A>Categories can also be used to distribute the implementation 
of a new class into separate source files--for example, you could group the 
methods of a large class into several categories and put each category in a 
different file. When used like this, categories can benefit the development 
process in a number of ways:
<P>
<UL><A name=774></A>
  <LI>They provide a simple way of grouping related methods. Similar methods 
  defined in different classes can be kept together in the same source file. <A 
  name=775></A>
  <LI>They simplify the management of a large class when more than one developer 
  is contributing to the class definition. <A name=776></A>
  <LI>They let you achieve some of the benefits of incremental compilation for a 
  very large class. <A name=777></A>
  <LI>They can help improve locality of reference for commonly used methods. <A 
  name=778></A>
  <LI>They enable you to configure a class differently for different 
  applications, without having to maintain different versions of the same source 
  code. </LI></UL><A name=779></A>Categories are also used to declare informal 
protocols, as discussed under ``<A 
href="http://toodarkpark.org/computers/objc/moreobjc.html#787">PROTOCOLS</A>'' 
below.
<P><A name=780></A>
<HR width="50%">

<CENTER><FONT size=+2>C<FONT size=+0><FONT size=+1>ategories of the<FONT 
size=+0> <FONT size=+2>R<FONT size=+1>oot<FONT size=+0> <FONT size=+2>C<FONT 
size=+1>lass<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=781></A>A category can add methods to any class, including the root 
class. Methods added to NSObject become available to all classes that are linked 
to your code. While this can be useful at times, it can also be quite dangerous. 
Although it may seem that the modifications the category makes are well 
understood and of limited impact, inheritance gives them a wide scope. You may 
be making unintended changes to unseen classes; you may not know all the 
consequences of what you're doing. Moreover, others who are unaware of your 
changes won't understand what they're doing.
<P><A name=782></A>In addition, there are two other considerations to keep in 
mind when implementing methods for the root class:
<P>
<UL><A name=783></A>
  <LI>Messages to <STRONG>super</STRONG> are invalid (there is no superclass). 
  <A name=784></A>
  <LI>Class objects can perform instance methods defined in the root class. 
</LI></UL><A name=785></A>Normally, class objects can perform only class 
methods. But instance methods defined in the root class are a special case. They 
define an interface to the run-time system that all objects inherit. Class 
objects are full-fledged objects and need to share the same interface.
<P><A name=786></A>This feature means that you need to take into account the 
possibility that an instance method you define in a category of the NSObject 
class might be performed not only by instances but by class objects as well. For 
example, within the body of the method, <STRONG>self</STRONG> might mean a class 
object as well as an instance. See the NSObject class specification in the 
<EM>Foundation Framework Reference</EM> for more information on class access to 
root instance methods.
<P><A name=787></A>
<HR width="75%">

<CENTER><FONT size=+3>P<FONT size=+0><FONT size=+2>rotocols<FONT size=+0> 
</CENTER>
<HR width="75%">

<P><A name=788></A>Class and category interfaces declare methods that are 
associated with a particular class--mainly methods that the class implements. 
Informal and formal <EM>protocols</EM>, on the other hand, declare methods not 
associated with a class, but which any class, and perhaps many classes, might 
implement.
<P><A name=789></A>A protocol is simply a list of method declarations, 
unattached to a class definition. For example, these methods that report user 
actions on the mouse could be gathered into a protocol:
<P><A name=2878></A><PRE>- (void)mouseDown:(NSEvent *)theEvent;<BR>
- (void)mouseDragged:(NSEvent *)theEvent;<BR>
- (void)mouseUp:(NSEvent *)theEvent;
</PRE><A name=791></A>Any class that wanted to respond to mouse events could 
adopt the protocol and implement its methods.
<P><A name=792></A>Protocols free method declarations from dependency on the 
class hierarchy, so they can be used in ways that classes and categories cannot. 
Protocols list methods that are (or may be) implemented somewhere, but the 
identity of the class that implements them is not of interest. What is of 
interest is whether or not a particular class <EM>conforms</EM> to the 
protocol--whether it has implementations of the methods the protocol declares. 
Thus objects can be grouped into types not just on the basis of similarities due 
to the fact that they inherit from the same class, but also on the basis of 
their similarity in conforming to the same protocol. Classes in unrelated 
branches of the inheritance hierarchy might be typed alike because they conform 
to the same protocol.
<P><A name=793></A>Protocols can play a significant role in object-oriented 
design, especially where a project is divided among many implementors or it 
incorporates objects developed in other projects. OPENSTEP software uses them 
heavily to support interprocess communication through Objective-C messages.
<P><A name=794></A>However, an Objective-C program doesn't need to use 
protocols. Unlike class definitions and message expressions, they're optional. 
Some OPENSTEP frameworks use them; some don't. It all depends on the task at 
hand.
<P><A name=795></A>
<HR width="50%">

<CENTER><FONT size=+2>H<FONT size=+0><FONT size=+1>ow<FONT size=+0> <FONT 
size=+2>P<FONT size=+0><FONT size=+1>rotocols are used<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=796></A>Protocols are useful in at least three different situations:
<P>
<UL><A name=797></A>
  <LI>To declare methods that others are expected to implement <A name=798></A>
  <LI>To declare the interface to an object while concealing its class <A 
  name=799></A>
  <LI>To capture similarities among classes that are not hierarchically related 
  </LI></UL><A name=800></A>The following sections discuss these situations and 
the roles protocols can play.
<P><A name=801></A>
<H3>Methods for Others to Implement</H3><A name=802></A>If you know the class of 
an object, you can look at its interface declaration (and the interface 
declarations of the classes it inherits from) to find what messages it responds 
to. These declarations advertise the messages it can receive. Protocols provide 
a way for it to also advertise the messages it sends.
<P><A name=803></A>Communication works both ways; objects send messages as well 
as receive them. For example, an object might delegate responsibility for a 
certain operation to another object, or it may on occasion simply need to ask 
another object for information. In some cases, an object might be willing to 
notify other objects of its actions so that they can take whatever collateral 
measures might be required.
<P><A name=804></A>If you develop the class of the sender and the class of the 
receiver as part of the same project (or if someone else has supplied you with 
the receiver and its interface file), this communication is easily coordinated. 
The sender simply imports the interface file of the receiver. The imported file 
declares the method selectors the sender uses in the messages it sends.
<P><A name=805></A>However, if you develop an object that sends messages to 
objects that aren't yet defined--objects that you're leaving for others to 
implement--you won't have the receiver's interface file. You need another way to 
declare the methods you use in messages but don't implement. A protocol serves 
this purpose. It informs the compiler about methods the class uses and also 
informs other implementors of the methods they need to define to have their 
objects work with yours.
<P><A name=806></A>Suppose, for example, that you develop an object that asks 
for the assistance of another object by sending it <STRONG>helpOut:</STRONG> and 
other messages. You provide an <STRONG>assistant</STRONG> instance variable to 
record the outlet for these messages and define a companion method to set the 
instance variable. This method lets other objects register themselves as 
potential recipients of your object's messages:
<P><A name=2890></A><PRE>- setAssistant:anObject<BR>
{<BR>
    assistant = anObject;<BR>
    return self;<BR>
}
</PRE><A name=808></A>Then, whenever a message is to be sent to the 
<STRONG>assistant</STRONG>, a check is made to be sure that the receiver 
implements a method that can respond:
<P><A name=2901></A><PRE>- (BOOL)doWork<BR>
{<BR>
    . . .
</PRE><A name=2899></A><PRE>    if ( [assistant respondsTo:@selector(helpOut:)] ) {<BR>
        [assistant helpOut:self];<BR>
        return YES;<BR>
    }<BR>
    return NO;<BR>
}
</PRE><A name=810></A>Since, at the time you write this code, you can't know 
what kind of object might register itself as the <STRONG>assistant</STRONG>, you 
can only declare a protocol for the <STRONG>helpOut:</STRONG> method; you can't 
import the interface file of the class that implements it.
<P><A name=811></A>
<H3>Anonymous Objects</H3><A name=812></A>A protocol can also be used to declare 
the methods of an <EM>anonymous</EM> object, an object of unknown class. An 
anonymous object may represent a service or handle a limited set of functions, 
especially where only one object of its kind is needed. (Objects that play a 
fundamental role in defining an application's architecture and objects that you 
must initialize before using are not good candidates for anonymity.)
<P><A name=813></A>Objects can't be anonymous to their developers, of course, 
but they can be anonymous when the developer supplies them to someone else. For 
example, an anonymous object might be part of a framework or be located in a 
remote process:
<P>
<UL><A name=814></A>
  <LI>Someone who supplies a framework or a suite of objects for others to use 
  can include objects that are not identified by a class name or an interface 
  file. Lacking the name and class interface, users have no way of creating 
  instances of the class. Instead, the supplier must provide a ready-made 
  instance. Typically, a method in another class returns a usable object: <A 
  name=2905></A><PRE>id formatter = [receiver formattingService];
</PRE>
  <DL><A name=816></A>
    <DT>The object returned by the method is an object without a class identity, 
    at least not one the supplier is willing to reveal. For it to be of any use 
    at all, the supplier must be willing to identify at least some of the 
    messages that it can respond to. This is done by associating the object with 
    a list of methods declared in a protocol. </DT></DL><A name=817></A>
  <LI>It's possible to send Objective-C messages to <EM>remote 
  objects</EM>--objects in other applications. (The next section, ``<A 
  href="http://toodarkpark.org/computers/objc/moreobjc.html#904">REMOTE 
  MESSAGING</A>,'' discusses this possibility in more detail.) 
  <DL><A name=818></A>
    <DT>Each application has its own structure, classes, and internal logic. But 
    you don't need to know how another application works or what its components 
    are to communicate with it. As an outsider, all you need to know is what 
    messages you can send (the protocol) and where to send them (the receiver). 
    <A name=819></A>
    <DT>An application that publishes one of its objects as a potential receiver 
    of remote messages must also publish a protocol declaring the methods the 
    object will use to respond to those messages. It doesn't have to disclose 
    anything else about the object. The sending application doesn't need to know 
    the class of the object or use the class in its own design. All it needs is 
    the protocol. </DT></DL></LI></UL><A name=820></A>Protocols make anonymous 
objects possible. Without a protocol, there would be no way to declare an 
interface to an object without identifying its class.
<P><A name=821></A>Note: Even though the supplier of an anonymous object won't 
reveal its class, the object itself will reveal it at run time. A 
<STRONG>class</STRONG> message will return the anonymous object's class. The 
class object can then be queried with the <STRONG>name</STRONG> and 
<STRONG>superclass</STRONG> methods. However, there's usually little point in 
discovering this extra information; the information in the protocol is 
sufficient.
<P><A name=822></A>
<H3>Non-hierarchical Similarities</H3><A name=823></A>If more than one class 
implements a set of methods, those classes are often grouped under an abstract 
class that declares the methods they have in common. Each subclass may 
reimplement the methods in its own way, but the inheritance hierarchy and the 
common declaration in the abstract class captures the essential similarity 
between the subclasses.
<P><A name=824></A>However, sometimes it's not possible to group common methods 
in an abstract class. Classes that are unrelated in most respects might 
nevertheless need to implement some similar methods. This limited similarity may 
not justify a hierarchical relationship. For example, many different kinds of 
classes might implement methods to facilitate reference counting (this is just 
an example, since the Foundation Framework already implements reference counting 
for you):
<P><A name=2912></A><PRE>- setRefCount:(int)count;<BR>
- (int)refCount;<BR>
- incrementCount;<BR>
- decrementCount;
</PRE><A name=826></A>These methods could be grouped into a protocol and the 
similarity between implementing classes accounted for by noting that they all 
conform to the same protocol.
<P><A name=827></A>Objects can be typed by this similarity (the protocols they 
conform to), rather than by their class. For example, an NSMatrix must 
communicate with the objects that represent its cells. The NSMatrix could 
require each of these objects to be a kind of NSCell (a type based on class) and 
rely on the fact that all objects that inherit from the NSCell class will have 
the methods needed to respond to NSMatrix messages. Alternatively, the NSMatrix 
could require objects representing cells to have methods that can respond to a 
particular set of messages (a type based on protocol). In this case, the 
NSMatrix wouldn't care what class a cell object belonged to, just that it 
implemented the methods.
<P><A name=828></A>
<HR width="50%">

<CENTER><FONT size=+2>I<FONT size=+0><FONT size=+1>nformal<FONT size=+0> <FONT 
size=+2>P<FONT size=+0><FONT size=+1>rotocols<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=829></A>The simplest way of declaring a protocol is to group the 
methods in a category declaration:
<P><A name=2922></A><PRE>@interface NSObject ( RefCounting )<BR>
- setRefCount:(int)count;<BR>
- (int)refCount;<BR>
- incrementCount;<BR>
- decrementCount;<BR>
@end
</PRE><A name=831></A>Informal protocols are typically declared as categories of 
the NSObject class, since that broadly associates the method names with any 
class that inherits from NSObject. Since all classes inherit from the root 
class, the methods aren't restricted to any part of the inheritance hierarchy. 
(It would also be possible to declare an informal protocol as a category of 
another class to limit it to a certain branch of the inheritance hierarchy, but 
there is little reason to do so.)
<P><A name=832></A>When used to declare a protocol, a category interface doesn't 
have a corresponding implementation. Instead, classes that implement the 
protocol declare the methods again in their own interface files and define them 
along with other methods in their implementation files.
<P><A name=833></A>An informal protocol bends the rules of category declarations 
to list a group of methods but not associate them with any particular class or 
implementation.
<P><A name=834></A>Being informal, protocols declared in categories don't 
receive much language support. There's no type checking at compile time nor a 
check at run time to see whether an object conforms to the protocol. To get 
these benefits, you must use a formal protocol.
<P><A name=835></A>
<HR width="50%">

<CENTER><FONT size=+2>F<FONT size=+0><FONT size=+1>ormal<FONT size=+0> <FONT 
size=+2>P<FONT size=+0><FONT size=+1>protocols<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=836></A>The Objective-C language provides a way to formally declare a 
list of methods as a protocol. Formal protocols are supported by the language 
and the run-time system. For example, the compiler can check for types based on 
protocols, and objects can introspect at run time to report whether or not they 
conform to a protocol.
<P><A name=837></A>Formal protocols are declared with the 
<STRONG>@protocol</STRONG> directive:
<P><A name=2934></A><PRE>@protocol <EM>ProtocolName<BR>
method declarations<BR>
</EM>@end
</PRE><A name=839></A>For example, the reference-counting protocol could be 
declared like this:
<P><A name=2947></A><PRE>@protocol ReferenceCounting<BR>
- setRefCount:(int)count;<BR>
- (int)refCount;<BR>
- incrementCount;<BR>
- decrementCount;<BR>
@end
</PRE><A name=841></A>Unlike class names, protocol names don't have global 
visibility. They live in their own name space.
<P><A name=842></A>A class is said to <EM>adopt</EM> a formal protocol if it 
agrees to implement the methods the protocol declares. Class declarations list 
the names of adopted protocols within angle brackets after the superclass name:
<P><A name=2955></A><PRE>@interface <EM>ClassName</EM> : <EM>ItsSuperclass</EM> <BR>
&lt; <EM>protocol list</EM> &gt;
</PRE><A name=844></A>Categories adopt protocols in much the same way:
<P><A name=2962></A><PRE>@interface <EM>ClassName</EM> ( <EM>CategoryName</EM> ) <BR>
&lt; <EM>protocol list</EM> &gt;
</PRE><A name=846></A>Names in the protocol list are separated by commas.
<P><A name=847></A>A class or category that adopts a protocol must import the 
header file where the protocol is declared. The methods declared in the adopted 
protocol are not declared elsewhere in the class or category interface.
<P><A name=848></A>It's possible for a class to simply adopt protocols and 
declare no other methods. For example, this class declaration,
<P><A name=2967></A><PRE>@interface Formatter : NSObject &lt; Formatting, Prettifying &gt;<BR>
@end
</PRE><A name=850></A>adopts the Formatting and Prettifying protocols, but 
declares no instance variables or methods of its own.
<P><A name=851></A>A class or category that adopts a protocol is obligated to 
implement all the methods the protocol declares. The compiler will issue a 
warning if it does not. The Formatter class above would define all the methods 
declared in the two protocols it adopts, in addition to any it might have 
declared itself.
<P><A name=852></A>Adopting a protocol is similar in some ways to declaring a 
superclass. Both assign methods to the new class. The superclass declaration 
assigns it inherited methods; the protocol assigns it methods declared in the 
protocol list.
<P><A name=853></A>
<H3>Protocol Objects</H3><A name=854></A>Just as classes are represented at run 
time by class objects and methods by selector codes, formal protocols are 
represented by a special data type--instances of the Protocol class. Source code 
that deals with a protocol (other than to use it in a type specification) must 
refer to the Protocol object.
<P><A name=855></A>In many ways, protocols are similar to class definitions. 
They both declare methods, and at run time they're both represented by 
objects--classes by class objects and protocols by Protocol objects. Like class 
objects, Protocol objects are created automatically from the definitions and 
declarations found in source code and are used by the run-time system. They're 
not allocated and initialized in program source code.
<P><A name=856></A>Source code can refer to a Protocol object using the 
<STRONG>@protocol()</STRONG> directive--the same directive that declares a 
protocol, except that here it has a set of trailing parentheses. The parentheses 
enclose the protocol name:
<P><A name=2976></A><PRE>Protocol *counter = @protocol(ReferenceCounting);
</PRE><A name=858></A>This is the only way that source code can conjure up a 
Protocol object. Unlike a class name, a protocol name doesn't designate the 
object--except inside <STRONG>@protocol()</STRONG>.
<P><A name=859></A>The compiler creates a Protocol object for each protocol 
declaration it encounters, but only if the protocol is also:
<P>
<UL><A name=860></A>
  <LI>Adopted by a class, or <A name=861></A>
  <LI>Referred to somewhere in source code (using <STRONG>@protocol()</STRONG>). 
  </LI></UL><A name=862></A>Protocols that are declared but not used (except for 
type checking as described below) aren't represented by Protocol objects.
<P><A name=863></A>
<H3>Conforming to a Protocol</H3><A name=864></A>A class is said to 
<EM>conform</EM> to a formal protocol if it adopts the protocol or inherits from 
a class that adopts it. An instance of a class is said to conform to the same 
set of protocols its class conforms to.
<P><A name=865></A>Since a class must implement all the methods declared in the 
protocols it adopts, and those methods are inherited by its subclasses, saying 
that a class or an instance conforms to a protocol is tantamount to saying that 
it has in its repertoire all the methods that the protocol declares.
<P><A name=866></A>It's possible to check whether an object conforms to a 
protocol by sending it a <STRONG>conformsTo:</STRONG> message.
<P><A name=2983></A><PRE>if ( [receiver conformsTo:@protocol(ReferenceCounting)] )<BR>
[receiver incrementCount];
</PRE><A name=868></A>The <STRONG>conformsTo:</STRONG> test is very much like 
the <STRONG>respondsTo:</STRONG> test for a single method, except that it tests 
whether a protocol has been adopted (and presumably all the methods it declares 
implemented) rather than just whether one particular method has been 
implemented. Because it checks for a whole list of methods, 
<STRONG>conformsTo:</STRONG> can be more efficient than 
<STRONG>respondsTo:</STRONG>.
<P><A name=869></A>The <STRONG>conformsTo:</STRONG> test is also very much like 
the <STRONG>isKindOf:</STRONG> test, except that it tests for a type based on a 
protocol rather than a type based on the inheritance hierarchy.
<P><A name=870></A>
<H3>Type Checking</H3><A name=871></A>Type declarations for objects can be 
extended to include formal protocols. Protocols thus offer the possibility of 
another level of type checking by the compiler, one that's more abstract since 
it's not tied to particular implementations.
<P><A name=872></A>In a type declaration, protocol names are listed between 
angle brackets after the type name:
<P><A name=2991></A><PRE>- (id &lt;Formatting&gt;)formattingService;<BR>
id &lt;ReferenceCounting, AutoFreeing&gt; anObject;
</PRE><A name=874></A>Just as static typing permits the compiler to test for a 
type based on the class hierarchy, this syntax permits the compiler to test for 
a type based on conformance to a protocol.
<P><A name=875></A>For example, if Formatter is an abstract class, this 
declaration
<P><A name=2998></A><PRE>Formatter *anObject;
</PRE><A name=877></A>groups all objects that inherit from Formatter into a type 
and permits the compiler to check assignments against that type.
<P><A name=878></A>Similarly, this declaration,
<P><A name=3005></A><PRE>id &lt;Formatting&gt; anObject;
</PRE><A name=880></A>groups all objects that conform to the Formatting protocol 
into a type, regardless of their positions in the class hierarchy. The compiler 
can check to be sure that only objects that conform to the protocol are assigned 
to the type.
<P><A name=881></A>In each case, the type groups similar objects--either because 
they share a common inheritance, or because they converge on a common set of 
methods.
<P><A name=882></A>The two types can be combined in a single declaration:
<P><A name=3015></A>id &lt;Formatting&gt; anObject;
<P><A name=884></A>Protocols can't be used to type class objects. Only instances 
can be statically typed to a protocol, just as only instances can be statically 
typed to a class. (However, at run time, both classes and instances will respond 
to a <STRONG>conformsTo:</STRONG> message.)
<P><A name=885></A>
<H3>Protocols within Protocols</H3><A name=886></A>One protocol can incorporate 
others using the same syntax that classes use to adopt a protocol:
<P><A name=3020></A>@protocol <EM>ProtocolName</EM> &lt; <EM>protocol list</EM> 
<P><A name=888></A>All the protocols listed between angle brackets are 
considered part of the <EM>ProtocolName</EM> protocol. For example, if the 
Paging protocol incorporates the Formatting protocol,
<P><A name=3027></A><PRE>@protocol Paging &lt; Formatting &gt;
</PRE><A name=890></A>any object that conforms to the Paging protocol will also 
conform to Formatting. Type declarations
<P><A name=3034></A><PRE>id &lt;Paging&gt; someObject;
</PRE><A name=892></A>and <STRONG>conformsTo:</STRONG> messages
<P><A name=3041></A><PRE>if ( [anotherObject conformsTo:@protocol(Paging)] )<BR>
    . . .
</PRE><A name=894></A>need mention only the Paging protocol to test for 
conformance to Formatting as well.
<P><A name=895></A>When a class adopts a protocol, it must implement the methods 
the protocol declares, as mentioned earlier. In addition, it must conform to any 
protocols the adopted protocol incorporates. If an incorporated protocol 
incorporates still other protocols, the class must also conform to them. A class 
can conform to an incorporated protocol by either:
<P>
<UL><A name=896></A>
  <LI>Implementing the methods the protocol declares, or <A name=897></A>
  <LI>Inheriting from a class that adopts the protocol and implements the 
  methods. </LI></UL><A name=898></A>Suppose, for example, that the Pager class 
adopts the Paging protocol. If Pager is a subclass of NSObject, 
<P><A name=3048></A><PRE>@interface Pager : NSObject &lt; Paging &gt;
</PRE><A name=900></A>it must implement all the Paging methods, including those 
declared in the incorporated Formatting protocol. It adopts the Formatting 
protocol along with Paging.
<P><A name=901></A>On the other hand, if Pager is a subclass of Formatter (a 
class that independently adopts the Formatting protocol),
<P><A name=3055></A><PRE>@interface Pager : Formatter &lt; Paging &gt;
</PRE><A name=903></A>it must implement all the methods declared in the Paging 
protocol proper, but not those declared in Formatting. Pager inherits 
conformance to the Formatting protocol from Formatter.
<P><A name=592></A>
<H3>Referring to Other Protocols</H3><A name=373></A>When working on complex 
applications, you occasionally find yourself writing code that looks like this:
<P><A name=3062></A><PRE>#import "B.h"<BR>
<BR>
@protocol A<BR>
- Foo:(id &lt;B&gt;)anObject;<BR>
@end
</PRE><A name=563></A>where protocol B is declared like this:
<P><A name=3087></A><PRE>#import "A.h"<BR>
<BR>
@protocol B<BR>
- Bar:(id &lt;A&gt;)anObject;<BR>
@end
</PRE><A name=378></A>In such a situation, circularity results and neither file 
will compile correctly. To break this recursive cycle, you must use the 
<STRONG>@protocol</STRONG> directive to make a forward reference to the needed 
protocol instead of importing the interface file where the protocol is defined. 
The following code excerpt illustrates how you would do this:
<P><A name=3102></A><PRE>@protocol B;<BR>
<BR>
@protocol A<BR>
- Foo:(id &lt;B&gt;)anObject;<BR>
@end
</PRE><A name=601></A>Note that using the <STRONG>@protocol</STRONG> directive 
in this manner simply informs the compiler that ``B'' is a protocol to be 
defined later. It doesn't import the interface file where protocol B is defined.
<P><A name=904></A>
<HR width="75%">

<CENTER><FONT size=+3>R<FONT size=+0><FONT size=+2>emote<FONT size=+0> <FONT 
size=+3>M<FONT size=+0><FONT size=+2>essaging<FONT size=+0> </CENTER>
<HR width="75%">

<P><A name=905></A>Like most other programming languages, Objective-C was 
initially designed for programs that are executed as a single process in a 
single address space.
<P><A name=906></A>Nevertheless, the object-oriented model, where communication 
takes place between relatively self-contained units through messages that are 
resolved at run-time, would seem well suited for interprocess communication as 
well. It's not hard to imagine Objective-C messages between objects that reside 
in different address spaces (that is, in different tasks) or in different 
threads of execution of the same task.
<P><A name=907></A>For example, in a typical server-client interaction, the 
client task might send its requests to a designated object in the server, and 
the server might target specific client objects for the notifications and other 
information it sends.
<P><A name=908></A>Or imagine an interactive application that needs to do a good 
deal of computation to carry out a user command. It could simply put up an 
attention panel telling the user to wait while it was busy, or it could isolate 
the processing work in a subordinate task, leaving the main part of the 
application free to accept user input. Objects in the two tasks would 
communicate through Objective-C messages.
<P><A name=909></A>Similarly, several separate processes could cooperate on the 
editing of a single document. There could be a different editing tool for each 
type of data in the document. One task might be in charge of presenting a 
unified user interface on-screen and of sorting out which user instructions were 
the responsibility of which editing tool. Each cooperating task could be written 
in Objective-C, with Objective-C messages being the vehicle of communication 
between the user interface and the tools and between one tool and another.
<P><A name=910></A>
<HR width="50%">

<CENTER><FONT size=+2>D<FONT size=+0><FONT size=+1>istributed<FONT size=+0> 
<FONT size=+2>O<FONT size=+0><FONT size=+1>bjects<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=911></A>Remote messaging in Objective-C requires a run-time system 
that can establish connections between objects in different address spaces, 
recognize when a message is intended for a remote address, and transfer data 
from one address space to another. It must also mediate between the separate 
schedules of the two tasks; it has to hold messages until their remote receivers 
are free to respond to them.
<P><A name=912></A>OPENSTEP includes a <EM>distributed objects</EM> architecture 
that is essentially this kind of extension to the run-time system. Using 
distributed objects, you can send Objective-C messages to objects in other tasks 
or have messages executed in other threads of the same task. (When remote 
messages are sent between two threads of the same task, the threads are treated 
exactly like threads in different tasks.)
<P><A name=913></A>To send a remote message, an application must first establish 
a connection with the remote receiver. Establishing the connection gives the 
application a proxy for the remote object in its own address space. It then 
communicates with the remote object through the proxy. The proxy assumes the 
identity of the remote object; it has no identity of its own. The application is 
able to regard the proxy as if it were the remote object; for most purposes, it 
<EM>is</EM> the remote object.
<P><A name=914></A>Remote messaging is diagrammed below, where object A 
communicates with object B through a proxy, and messages for B wait in a queue 
until B is ready to respond to them:
<P><A name=915></A>
<P><IMG hspace=10 src="" align=left> <A name=916></A>The sender and receiver are 
in different tasks and are scheduled independently of each other. So there's no 
guarantee that the receiver will be free to accept a message when the sender is 
ready to send it. Therefore, arriving messages are placed in a queue and 
retrieved at the convenience of the receiving application.
<P><A name=917></A>A proxy doesn't act on behalf of the remote object or need 
access to its class. It isn't a copy of the object, but a lightweight substitute 
for it. In a sense, it's transparent; it simply passes the messages it receives 
on to the remote receiver and manages the interprocess communication. Its main 
function is to provide a local address for an object that wouldn't otherwise 
have one.
<P><A name=918></A>A remote receiver is typically anonymous. Its class is hidden 
inside the remote application. The sending application doesn't need to know how 
that application is designed or what classes it uses. It doesn't need to use the 
same classes itself. All it needs to know is what messages the remote object 
responds to.
<P><A name=919></A>Because of this, an object that's designated to receive 
remote messages typically advertises its interface in a formal protocol. Both 
the sending and the receiving application declare the protocol--they both import 
the same protocol declaration. The receiving application declares it because the 
remote object must conform to the protocol. The sending application declares it 
to inform the compiler about the messages it sends and because it may use the 
<STRONG>conformsTo:</STRONG> method and the <STRONG>@protocol()</STRONG> 
directive to test the remote receiver. The sending application doesn't have to 
implement any of the methods in the protocol; it declares the protocol only 
because it initiates messages to the remote receiver.
<P><A name=920></A>The distributed objects architecture, including the NSProxy 
and NSConnection classes, is documented in the <EM>Foundation Framework 
Reference</EM>.
<P><A name=921></A>
<HR width="50%">

<CENTER><FONT size=+2>L<FONT size=+0><FONT size=+1>anguage<FONT size=+0> <FONT 
size=+2>S<FONT size=+0><FONT size=+1>upport<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=922></A>Remote messaging raises not only a number of intriguing 
possibilities for program design, it also raises some interesting issues for the 
Objective-C language. Most of the issues are related to the efficiency of remote 
messaging and the degree of separation that the two tasks should maintain while 
they're communicating with each other.
<P><A name=923></A>So that programmers can give explicit instructions about the 
intent of a remote message, Objective-C defines six type qualifiers that can be 
used when declaring methods inside a formal protocol:
<P>
<DL>
  <DL><A name=924></A>
    <DT>oneway<BR>in<BR>out<BR>inout<BR>bycopy<BR>byref </DT></DL></DL><A 
name=925></A>These modifiers are restricted to formal protocols; they can't be 
used inside class and category declarations. However, if a class or category 
adopts a protocol, its implementation of the protocol methods can use the same 
modifiers that are used to declare the methods.
<P><A name=926></A>The following sections explain how these modifiers are used.
<P><A name=927></A>
<H3>Synchronous and Asynchronous Messages</H3><A name=928></A>Consider first a 
method with just a simple return value:
<P><A name=3110></A><PRE>- (BOOL)canDance;
</PRE><A name=930></A>When a <STRONG>canDance</STRONG> message is sent to a 
receiver in the same application, the method is invoked and the return value 
provided directly to the sender. But when the receiver is in a remote 
application, two underlying messages are required--one message to get the remote 
object to invoke the method, and the other message to send back the result of 
the remote calculation. This is illustrated in the figure below:
<P><A name=931></A>
<P><IMG hspace=10 src="" align=left> <A name=932></A>Most remote messages will 
be, at bottom, two-way (or ``round trip'') remote procedure calls (RPCs) like 
this one. The sending application waits for the receiving application to invoke 
the method, complete its processing, and send back an indication that it has 
finished, along with any return information requested. Waiting for the receiver 
to finish, even if no information is returned, has the advantage of coordinating 
the two communicating applications, of keeping them both ``in sync.'' For this 
reason, round-trip messages are often called synchronous. Synchronous messages 
are the default.
<P><A name=933></A>However, it's not always necessary or a good idea to wait for 
a reply. Sometimes it's sufficient simply to dispatch the remote message and 
return, allowing the receiver to get to the task when it will. In the meantime, 
the sender can go on to other things. Objective-C provides a return type 
modifier, <STRONG>oneway</STRONG>, to indicate that a method is used only for 
<EM>asynchronous</EM> messages:
<P><A name=3117></A><PRE>- (oneway void)waltzAtWill;
</PRE><A name=935></A>Although <STRONG>oneway</STRONG> is a type qualifier (like 
<STRONG>const</STRONG>) and can be used in combination with a specific type 
name, such as <STRONG>oneway float</STRONG> or <STRONG>oneway id</STRONG>, the 
only such combination that makes any sense is <STRONG>oneway void</STRONG>. An 
asynchronous message can't have a valid return value.
<P><A name=936></A>
<H3>Pointer Arguments</H3><A name=937></A>Next, consider methods that take 
pointer arguments. A pointer can be used to pass information to the receiver by 
reference. When invoked, the method looks at what's stored in the address it's 
passed.
<P><A name=3124></A><PRE>- setTune:(struct tune *)aSong<BR>
{<BR>
    tune = *aSong;<BR>
    . . .<BR>
}
</PRE><A name=939></A>The same sort of argument can also be used to return 
information by reference. The method uses the pointer to find where it should 
place information requested in the message.
<P><A name=3131></A><PRE>- getTune:(struct tune *)theSong<BR>
{<BR>
    . . .<BR>
    *theSong = tune;<BR>
}
</PRE><A name=941></A>The way the pointer is used makes a difference in how the 
remote message is carried out. In neither case can the pointer simply be passed 
to the remote object unchanged; it points to a memory location in the sender's 
address space and would not be meaningful in the address space of the remote 
receiver. The run-time system for remote messaging must make some adjustments 
behind the scenes.
<P><A name=942></A>If the argument is used to pass information by reference, the 
run-time system must dereference the pointer, ship the value it points to over 
to the remote application, store the value in an address local to that 
application, and pass that address to the remote receiver.
<P><A name=943></A>If, on the other hand, the pointer is used to return 
information by reference, the value it points to doesn't have to be sent to the 
other application. Instead, a value from the other application must be sent back 
and written into the location indicated by the pointer.
<P><A name=944></A>In the one case, information is passed on the first leg of 
the round trip. In the other case, information is returned on the second leg of 
the round trip. Because these cases result in very different actions on the part 
of the run-time system for remote messaging, Objective-C provides type modifiers 
that can clarify the programmer's intention:
<P>
<UL><A name=945></A>
  <LI>The type modifier <STRONG>in</STRONG> indicates that information is being 
  passed in a message: <A name=3138></A><PRE>- setTune:(in struct tune *)aSong;
</PRE><A name=947></A>
  <LI>The modifier <STRONG>out</STRONG> indicates that an argument is being used 
  to return information by reference: <A name=3145></A><PRE>- getTune:(out struct tune *)theSong;
</PRE><A name=949></A>
  <LI>A third modifier, <STRONG>inout</STRONG>, indicates that an argument is 
  used both to provide information and to get information back: <A 
name=3152></A><PRE>- adjustTune:(inout struct tune *)aSong;
</PRE></LI></UL><A name=951></A>The OPENSTEP distributed objects system takes 
<STRONG>inout</STRONG> to be the default modifier for all pointer arguments 
except those declared <STRONG>const</STRONG>, for which <STRONG>in</STRONG> is 
the default. <STRONG>inout</STRONG> is the safest assumption, but also the most 
time-consuming since it requires passing information in both directions. The 
only modifier that makes sense for arguments passed by value (non-pointers) is 
<STRONG>in</STRONG>. While <STRONG>in</STRONG> can be used with any kind of 
argument, <STRONG>out</STRONG> and <STRONG>inout</STRONG> make sense only for 
pointers.
<P><A name=952></A>In C, pointers are sometimes used to represent composite 
values. For example, a string is represented as a character pointer 
(<STRONG>char *</STRONG>). Although in notation and implementation there's a 
level of indirection here, in concept there's not. Conceptually, a string is an 
entity in and of itself, not a pointer to something else.
<P><A name=953></A>In cases like this, the distributed objects system 
automatically dereferences the pointer and passes whatever it points to as if by 
value. Therefore, the <STRONG>out</STRONG> and <STRONG>inout</STRONG> modifiers 
make no sense with simple character pointers. It takes an additional level of 
indirection in a remote message to pass or return a string by reference:
<P><A name=3159></A><PRE>- getTuneTitle:(out char **)theTitle;
</PRE><A name=955></A>The same is true of objects:
<P><A name=3166></A><PRE>- adjustRectangle:(inout Rectangle **)theRect;
</PRE><A name=957></A>These conventions are enforced at run time, not by the 
compiler.
<P><A name=958></A>
<H3>Proxies and Copies</H3><A name=959></A>Finally, consider a method that takes 
an object as an argument:
<P><A name=3173></A><PRE>- danceWith:(id)aPartner;
</PRE><A name=961></A>A <STRONG>danceWith:</STRONG> message passes an object 
<STRONG>id</STRONG> to the receiver. If the sender and receiver are in the same 
application, they would both be able to refer to the same <EM>aPartner</EM> 
object.
<P><A name=962></A>This is true even if the receiver is in a remote application, 
except that the receiver will need to refer to the object through a proxy (since 
the object isn't in its address space). The pointer that 
<STRONG>danceWith:</STRONG> delivers to a remote receiver is actually a pointer 
to the proxy. Messages sent to the proxy would be passed across the connection 
to the real object and any return information would be passed back to the remote 
application.
<P><A name=963></A>There are times when proxies may be unnecessarily 
inefficient, when it's better to send a copy of the object to the remote process 
so that it can interact with it directly in its own address space. To give 
programmers a way to indicate that this is intended, Objective-C provides a 
<STRONG>bycopy</STRONG> type modifier:
<P><A name=3180></A><PRE>- danceWith:(bycopy id)aClone;
</PRE><A name=965></A><STRONG>bycopy</STRONG> can also be used for return 
values:
<P><A name=3187></A><PRE>- (bycopy)dancer;
</PRE><A name=967></A>It can similarly be used with <STRONG>out</STRONG> to 
indicate that an object returned by reference should be copied rather than 
delivered in the form of a proxy:
<P><A name=3194></A><PRE>- getDancer:(bycopy out id *)theDancer;
</PRE><A name=545></A>Note: When a copy of an object is passed to another 
application, it cannot be anonymous. The application that receives the object 
must have the class of the object loaded in its address space.
<P><A name=371></A><STRONG>bycopy</STRONG> makes so much sense for certain 
classes--classes that are intended to contain a collection of other objects, for 
instance--that often these classes are written so that a copy is sent to a 
remote receiver, instead of the usual reference. You can override this behavior 
with <STRONG>byref</STRONG>, however, thereby specifying that objects passed 
into or out of a method should all be passed by reference. Since passing by 
reference is the default behavior for the vast majority of Objective-C objects, 
you will rarely, if ever, make use of the <STRONG>byref</STRONG> keyword.
<P><A name=543></A>The only type that it makes sense for <STRONG>bycopy</STRONG> 
or <STRONG>byref</STRONG> to modify is an object, whether dynamically typed 
<STRONG>id</STRONG> or statically typed by a class name.
<P><A name=544></A>Although <STRONG>bycopy</STRONG> and <STRONG>byref</STRONG> 
can't be used inside class and category declarations, they can be used within 
formal protocols. For instance, you could write a formal protocol 
<STRONG>foo</STRONG> as follows:
<P><A name=3201></A><PRE>@Protocol foo<BR>
    - (bycopy)array;<BR>
@end
</PRE><A name=542></A>A class or category can then adopt your protocol 
<STRONG>foo</STRONG>. This allows you to construct protocols so that they 
provide ``hints'' as to how objects should be passed and returned by the methods 
described by the protocol.
<P><A name=969></A>
<HR width="75%">

<CENTER><FONT size=+3>S<FONT size=+0><FONT size=+2>tatic<FONT size=+0> <FONT 
size=+3>O<FONT size=+0><FONT size=+2>ptions<FONT size=+0> </CENTER>
<HR width="75%">

<P><A name=970></A>Objective-C objects are dynamic entities. As many decisions 
about them as possible are pushed from compile time to run time:
<P>
<UL><A name=971></A>
  <LI>The memory for objects is <EM>dynamically allocated</EM> at run time by 
  class methods that create new instances. <A name=972></A>
  <LI>Objects are <EM>dynamically typed</EM>. In source code (at compile time), 
  any object can be of type <STRONG>id</STRONG> no matter what its class. The 
  exact class of an <STRONG>id</STRONG> variable (and therefore its particular 
  methods and data structure) isn't determined until the program is running. <A 
  name=973></A>
  <LI>Messages and methods are <EM>dynamically bound</EM>, as described under 
  ``<A href="http://toodarkpark.org/computers/objc/coreobjc.html#">HOW MESSAGING 
  WORKS</A>'' in the previous chapter. A run-time procedure matches the method 
  selector in the message to a method implementation that ``belongs to'' the 
  receiver. </LI></UL><A name=974></A>These features give object-oriented programs 
a great deal of flexibility and power, but there's a price to pay. Messages are 
somewhat slower than function calls, for example, (though not much slower due to 
the efficiency of the run-time system) and the compiler can't check the exact 
types (classes) of <STRONG>id</STRONG> variables.
<P><A name=975></A>To permit better compile-time type checking, and to make code 
more self-documenting, Objective-C allows objects to be statically typed with a 
class name rather than generically typed as <STRONG>id</STRONG>. It also lets 
you turn some of its object-oriented features off in order to shift operations 
from run time back to compile time.
<P><A name=976></A>
<HR width="50%">

<CENTER><FONT size=+3>S<FONT size=+0><FONT size=+2>tatic<FONT size=+0> <FONT 
size=+3>T<FONT size=+0><FONT size=+2>yping<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=977></A>If a pointer to a class name is used in place of 
<STRONG>id</STRONG> in an object declaration,
<P><A name=3212></A><PRE>Rectangle  *thisObject;
</PRE><A name=979></A>the compiler restricts the declared variable to be either 
an instance of the class named in the declaration or an instance of a class that 
inherits from the named class. In the example above, <STRONG>thisObject</STRONG> 
can only be a Rectangle of some kind.
<P><A name=980></A>Statically typed objects have the same internal data 
structures as objects declared to be <STRONG>id</STRONG>s. The type doesn't 
affect the object; it affects only the amount of information given to the 
compiler about the object and the amount of information available to those 
reading the source code.
<P><A name=981></A>Static typing also doesn't affect how the object is treated 
at run time. Statically typed objects are dynamically allocated by the same 
class methods that create instances of type <STRONG>id</STRONG>. If Square is a 
subclass of Rectangle, the following code would still produce an object with all 
the instance variables of a Square, not just those of a Rectangle:
<P><A name=3219></A><PRE>Rectangle  *thisObject = [[Square alloc] init];
</PRE><A name=983></A>Messages sent to statically typed objects are dynamically 
bound, just as objects typed <STRONG>id</STRONG> are. The exact type of a 
statically typed receiver is still determined at run time as part of the 
messaging process. A <STRONG>display</STRONG> message sent to 
<STRONG>thisObject</STRONG>
<P><A name=3226></A><PRE>[thisObject display];
</PRE><A name=985></A>will perform the version of the method defined in the 
Square class, not its Rectangle superclass.
<P><A name=986></A>By giving the compiler more information about an object, 
static typing opens up possibilities that are absent for objects typed 
<STRONG>id</STRONG>:
<P>
<UL><A name=987></A>
  <LI>In certain situations, it allows for compile-time type checking. <A 
  name=988></A>
  <LI>It can free objects from the restriction that identically named methods 
  must have identical return and argument types. <A name=989></A>
  <LI>It permits you to use the structure pointer operator to directly access an 
  object's instance variables. </LI></UL><A name=990></A>The first two topics are 
discussed in the sections below. The third was covered in the previous chapter 
under ``<A href="http://toodarkpark.org/computers/objc/coreobjc.html#">DEFINING 
A CLASS</A>.''
<P><A name=991></A>
<H3>Type Checking</H3><A name=992></A>With the additional information provided 
by static typing, the compiler can deliver better type-checking services in two 
situations:
<P>
<UL><A name=993></A>
  <LI>When a message is sent to a statically typed receiver, the compiler can 
  check to be sure that the receiver can respond. A warning is issued if the 
  receiver doesn't have access to the method named in the message. <A 
  name=994></A>
  <LI>When a statically typed object is assigned to a statically typed variable, 
  the compiler can check to be sure that the types are compatible. A warning is 
  issued if they're not. </LI></UL><A name=995></A>An assignment can be made 
without warning provided the class of the object being assigned is identical to, 
or inherits from, the class of the variable receiving the assignment. This is 
illustrated in the example below.
<P><A name=3233></A><PRE>Shape    *aShape;<BR>
Rectangle  *aRect;<BR>
<BR>
aRect = [[Rectangle alloc] init];<BR>
aShape = aRect;
</PRE><A name=997></A>Here <STRONG>aRect</STRONG> can be assigned to 
<STRONG>aShape</STRONG> because a Rectangle is a kind of Shape--the Rectangle 
class inherits from Shape. However, if the roles of the two variables are 
reversed and <STRONG>aShape</STRONG> is assigned to <STRONG>aRect</STRONG>, the 
compiler will generate a warning; not every Shape is a Rectangle. (For 
reference, see the figure in the previous chapter that shows the class hierarchy 
including Shape and Rectangle.)
<P><A name=998></A>There's no check when the expression on either side of the 
assignment operator is an <STRONG>id</STRONG>. A statically typed object can be 
freely assigned to an <STRONG>id</STRONG>, or an <STRONG>id</STRONG> to a 
statically typed object. Because methods like <STRONG>alloc</STRONG> and 
<STRONG>init</STRONG> return <STRONG>id</STRONG>s, the compiler doesn't check to 
be sure that a compatible object is returned to a statically typed variable. The 
following code is error-prone, but is allowed nonetheless:
<P><A name=3241></A><PRE>Rectangle  *aRect;<BR>
aRect = [[Shape alloc] init];
</PRE><A name=1000></A>Note: This is consistent with the implementation of 
<STRONG>void *</STRONG> (pointer to <STRONG>void</STRONG>) in ANSI C. Just as 
<STRONG>void *</STRONG> is a generic pointer that eliminates the need for 
coercion in assignments between pointers, <STRONG>id</STRONG> is a generic 
pointer to objects that eliminates the need for coercion to a particular class 
in assignments between objects.
<P><A name=1001></A>
<H3>Return and Argument Types</H3><A name=1002></A>In general, methods that 
share the same selector (the same name) must also share the same return and 
argument types. This constraint is imposed by dynamic binding. Because the class 
of a message receiver, and therefore class-specific details about the method 
it's asked to perform, can't be known at compile time, the compiler must treat 
all methods with the same name alike. When it prepares information on method 
return and argument types for the run-time system, it creates just one method 
description for each method selector.
<P><A name=1003></A>However, when a message is sent to a statically typed 
object, the class of the receiver is known by the compiler. The compiler has 
access to class-specific information about the methods. Therefore, the message 
is freed from the restrictions on its return and argument types.
<P><A name=1004></A>
<H3>Static Typing to an Inherited Class</H3><A name=1005></A>An instance can be 
statically typed to its own class or to any class that it inherits from. All 
instances, for example, can be statically typed as NSObjects.
<P><A name=1006></A>However, the compiler understands the class of a statically 
typed object only from the class name in the type designation, and it does its 
type checking accordingly. Typing an instance to an inherited class can 
therefore result in discrepancies between what the compiler thinks would happen 
at run time and what will actually happen.
<P><A name=1007></A>For example, if you statically type a Rectangle instance as 
a Shape,
<P><A name=3248></A><PRE>Shape *myRect = [[Rectangle alloc] init];
</PRE><A name=1009></A>the compiler will treat it as a Shape. If you send the 
object a message to perform a Rectangle method,
<P><A name=3255></A><PRE>BOOL solid = [myRect isFilled];
</PRE><A name=1011></A>the compiler will complain. The <STRONG>siFilled</STRONG> 
method is defined in the Rectangle class, not in Shape.
<P><A name=1012></A>However, if you send it a message to perform a method that 
the Shape class knows about,
<P><A name=3262></A><PRE>[myRect display];
</PRE><A name=1014></A>the compiler won't complain, even though Rectangle 
overrides the method. At run time, Rectangle's version of the method will be 
performed.
<P><A name=1015></A>Similarly, suppose that the Upper class declares a 
<STRONG>worry</STRONG> method that returns a <STRONG>double</STRONG>,
<P><A name=3269></A><PRE>- (double)worry;
</PRE><A name=1017></A>and the Middle subclass of Upper overrides the method and 
declares a new return type:
<P><A name=3276></A><PRE>- (int)worry;
</PRE><A name=1019></A>If an instance is statically typed to the Upper class, 
the compiler will think that its <STRONG>worry</STRONG> method returns a 
<STRONG>double</STRONG>, and if an instance is typed to the Middle class, it 
will think that <STRONG>worry</STRONG> returns an <STRONG>int</STRONG>. Errors 
will obviously result if a Middle instance is typed to the Upper class. The 
compiler will inform the run-time system that a <STRONG>worry</STRONG> message 
sent to the object will return a double, but at run time it will actually return 
an <STRONG>int</STRONG> and generate an error.
<P><A name=1020></A>Static typing can free identically named methods from the 
restriction that they must have identical return and argument types, but it can 
do so reliably only if the methods are declared in different branches of the 
class hierarchy.
<P><A name=1021></A>
<HR width="50%">

<CENTER><FONT size=+2>G<FONT size=+0><FONT size=+1>etting a<FONT size=+0> <FONT 
size=+2>M<FONT size=+0><FONT size=+1>ethod<FONT size=+0> <FONT size=+2>A<FONT 
size=+0><FONT size=+1>ddress<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1022></A>The only way to circumvent dynamic binding is to get the 
address of a method and call it directly as if it were a function. This might be 
appropriate on the rare occasions when a particular method will be performed 
many times in succession and you want to avoid the overhead of messaging each 
time the method is performed.
<P><A name=1023></A>With a method defined in the NSObject class, 
<STRONG>methodForSelector:</STRONG>, you can ask for a pointer to the procedure 
that implements a method, then use the pointer to call the procedure. The 
pointer that <STRONG>methodForSelector:</STRONG> returns must be carefully cast 
to the proper function type. Both return and argument types should be included 
in the cast.
<P><A name=1024></A>The example below shows how the procedure that implements 
the <STRONG>setFilled:</STRONG> method might be called:
<P><A name=3285></A><PRE>void (*setter)(id, SEL, BOOL);<BR>
int  i;<BR>
<BR>
setter = (void (*)(id, SEL, BOOL))[target<BR>
    methodForSelector:@selector(setFilled:)];<BR>
for ( i = 0; i &lt; 1000, i++ )<BR>
    setter(targetList[i], @selector(setFilled:), True);
</PRE><A name=1026></A>The first two arguments passed to the procedure are the 
receiving object (<STRONG>self</STRONG>) and the method selector 
(<STRONG>_cmd</STRONG>). These arguments are hidden in method syntax but must be 
made explicit when the method is called as a function.
<P><A name=1027></A>Using <STRONG>methodForSelector:</STRONG> to circumvent 
dynamic binding saves most of the time required by messaging. However, the 
savings will be significant only where a particular message will be repeated 
many times, as in the <STRONG>for</STRONG> loop shown above.
<P><A name=1028></A>Note that <STRONG>methodForSelector:</STRONG> is provided by 
the run-time system; it's not a feature of the Objective-C language itself.
<P><A name=1029></A>
<HR width="50%">

<CENTER><FONT size=+2>G<FONT size=+0><FONT size=+1>etting an<FONT size=+0> <FONT 
size=+2>O<FONT size=+0><FONT size=+1>bject<FONT size=+0> <FONT size=+2>D<FONT 
size=+0><FONT size=+1>ata<FONT size=+0> <FONT size=+2>S<FONT size=+0><FONT 
size=+1>tructure<FONT size=+0> </CENTER>
<HR width="50%">

<P><A name=1030></A>A fundamental tenet of object-oriented programming is that 
the data structure of an object is private to the object. Information stored 
there can be accessed only through messages sent to the object. However, there's 
a way to strip an object data structure of its ``objectness'' and treat it like 
any other C structure. This makes all the object's instance variables publicly 
available.
<P><A name=1031></A>When given a class name as an argument, the 
<STRONG>@defs()</STRONG> directive produces the declaration list for an instance 
of the class. This list is useful only in declaring structures, so 
<STRONG>@defs()</STRONG> can appear only in the body of a structure declaration. 
This code, for example, declares a structure that would be identical to the 
template for an instance of the Worker class:
<P><A name=3292></A><PRE>struct workerDef {<BR>
    @defs(Worker)<BR>
} *public;
</PRE><A name=1033></A>Here <STRONG>public</STRONG> is declared as a pointer to 
a structure that's essentially indistinguishable from a Worker instance. With a 
little help from a type cast, a Worker <STRONG>id</STRONG> can be assigned to 
the pointer. The object's instance variables can then be accessed publicly 
through the pointer:
<P><A name=3299></A><PRE>id  aWorker;<BR>
aWorker = [[Worker alloc] init];<BR>
<BR>
public = (struct workerDef *)aWorker;<BR>
public-&gt;boss = nil;
</PRE><A name=1035></A>This technique of turning an object into a structure 
makes all of its instance variables public, no matter whether they were declared 
<STRONG>@private</STRONG>, <STRONG>@protected</STRONG>, or 
<STRONG>@public</STRONG>.
<P><A name=1036></A>Objects generally aren't designed with the expectation that 
they'll be turned into C structures. You may want to use 
<STRONG>@defs()</STRONG> for classes you define entirely yourself, but it should 
not be applied to classes found in a library or to classes you define that 
inherit from library classes.
<P><A name=1037></A>
<HR width="75%">

<CENTER><FONT size=+3>T<FONT size=+0><FONT size=+2>ype<FONT size=+0> <FONT 
size=+3>E<FONT size=+0><FONT size=+2>ncoding<FONT size=+0> </CENTER>
<HR width="75%">

<P><A name=1038></A>To assist the run-time system, the compiler encodes the 
return and argument types for each method in a character string and associates 
the string with the method selector. The coding scheme it uses might also be of 
use in other contexts and so is made publicly available with the 
<STRONG>@encode()</STRONG> directive. When given a type specification, 
<STRONG>@encode()</STRONG> returns a string encoding that type. The type can be 
a basic type such as an <STRONG>int</STRONG>, a pointer, a tagged structure or 
union, or a class name--anything, in fact, that can be used as an argument to 
the C <STRONG>sizeof()</STRONG> operator.
<P><A name=3311></A><PRE>char  *buf1 = @encode(int **);<BR>
char  *buf2 = @encode(struct key);<BR>
char  *buf3 = @encode(Rectangle);
</PRE><A name=3320></A>The table below lists the type codes. Note that many of 
them overlap with the codes used in writing to a typed stream. However, there 
are codes listed here that you can't use when writing to a typed stream and 
there are codes that you may want to use when writing to a typed stream that 
aren't generated by <STRONG>@encode()</STRONG>. (See the <EM>Foundation 
Framework Reference</EM> for information on typed streams.)
<P><A name=3321></A><A name=3322></A><A name=3428></A><A name=1043></A><A 
name=3432></A><A name=3433></A><A name=3435></A><A name=3434></A><A 
name=3436></A><A name=289></A><A name=3439></A><A name=1046></A><A 
name=3440></A><A name=1047></A><A name=3441></A><A name=1048></A><A 
name=3442></A><A name=1049></A><A name=3443></A><A name=322></A><A 
name=3444></A><A name=1050></A><A name=3445></A><A name=1051></A><A 
name=3446></A><A name=1052></A><A name=3447></A><A name=1053></A><A 
name=3448></A><A name=1054></A><A name=3449></A><A name=1055></A><A 
name=3450></A><A name=1056></A><A name=3451></A><A name=1057></A><A 
name=3452></A><A name=1058></A><A name=3453></A><A name=1059></A><A 
name=3454></A><A name=1060></A><A name=3455></A><A name=1061></A><A 
name=3456></A><A name=1062></A><A name=3457></A><A name=1064></A>
<TABLE cellSpacing=2 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD align=middle width="15%"><FONT size=+1><B>Code</B></FONT> </TD>
    <TD align=left><FONT size=+1><B>Meaning</B></FONT> </TD></TR>
  <TR>
    <TD align=middle>c </TD>
    <TD align=left>A char </TD></TR>
  <TR>
    <TD align=middle>i </TD>
    <TD align=left>A int</TD></TR>
  <TR>
    <TD align=middle>s </TD>
    <TD align=left>A short</TD></TR>
  <TR>
    <TD align=middle>l </TD>
    <TD align=left>A long</TD></TR>
  <TR>
    <TD align=middle>q </TD>
    <TD align=left>A long long</TD></TR>
  <TR>
    <TD align=middle>C </TD>
    <TD align=left>An unsigned char</TD></TR>
  <TR>
    <TD align=middle>I </TD>
    <TD align=left>An unsigned int</TD></TR>
  <TR>
    <TD align=middle>L </TD>
    <TD align=left>An unsigned long </TD></TR>
  <TR>
    <TD align=middle>Q </TD>
    <TD align=left>An unsigned long long</TD></TR>
  <TR>
    <TD align=middle>f </TD>
    <TD align=left>A float</TD></TR>
  <TR>
    <TD align=middle>d </TD>
    <TD align=left>A double</TD></TR>
  <TR>
    <TD align=middle>v </TD>
    <TD align=left>A void </TD></TR>
  <TR>
    <TD align=middle>* </TD>
    <TD align=left>A charactrer string (char*)</TD></TR>
  <TR>
    <TD align=middle>@ </TD>
    <TD align=left>An object (whether statically typed or typed id) </TD></TR>
  <TR>
    <TD align=middle># </TD>
    <TD align=left>A class objec (Class)</TD></TR>
  <TR>
    <TD align=middle>: </TD>
    <TD align=left>A method selector (SEL)</TD></TR>
  <TR>
    <TD align=middle>[...]</TD>
    <TD align=left>An array </TD></TR>
  <TR>
    <TD align=middle>{...} </TD>
    <TD align=left>A structure</TD></TR>
  <TR>
    <TD align=middle>(...)</TD>
    <TD align=left>A union</TD></TR>
  <TR>
    <TD align=middle>b<I>num</I> </TD>
    <TD align=left>A bitfield of <I>num</I> bits</TD></TR>
  <TR>
    <TD align=middle>^<I>type</I> </TD>
    <TD align=left>A pointer to <I>type</I></TD></TR>
  <TR>
    <TD align=middle>? </TD>
    <TD align=left>An unkown type </TD></TR></TBODY></TABLE>
<P>The type specification for an array is enclosed within square brackets; the 
number of elements in the array is specified immediately after the open bracket, 
before the array type. For example, an array of 12 pointers to 
<STRONG>float</STRONG>s would be encoded as:
<P><A name=3325></A><PRE>[12^f]
</PRE><A name=1066></A>Structures are specified within braces, and unions within 
parentheses. The structure tag is listed first, followed by an equal sign and 
the codes for the fields of the structure listed in sequence. For example, this 
structure,
<P><A name=3359></A><PRE>typedef struct example {<BR>
	id anObject;<BR>
	char *aString;<BR>
	int anInt;<BR>
} Example;
</PRE><A name=1068></A>would be encoded like this:
<P><A name=3366></A><PRE>{example=@*i}
</PRE><A name=1070></A>The same encoding results whether the defined type name 
(<STRONG>Example</STRONG>) or the structure tag (<STRONG>example</STRONG>) is 
passed to <STRONG>@encode()</STRONG>. The encoding for a structure pointer 
carries the same amount of information about the structure's fields:
<P><A name=3373></A><PRE>^{example=@*i}
</PRE><A name=1072></A>However, another level of indirection removes the 
internal type specification:
<P><A name=3380></A><PRE>^^{example}
</PRE><A name=1074></A>Objects are treated like structures. For example, passing 
the NSObject class name to </STRONG>@encode()</STRONG> yields this encoding:
<P><A name=3387></A><PRE>{NSObject=#}
</PRE><A name=1076></A>The NSObject class declares just one instance variable, 
<STRONG>isa</STRONG>, of type Class.
<P><A name=1077></A>Note: Although the <STRONG>@encode()</STRONG> directive 
doesn't return them, the run-time system also uses these additional encodings 
for type qualifiers when they're used to declare methods in a protocol:
<P><A name=1078></A><A name=1079></A><A name=3461></A><A name=1080></A><A 
name=3462></A><A name=1081></A><A name=3463></A><A name=1082></A><A 
name=3464></A><A name=1083></A><A name=3465></A><A name=541></A><A 
name=3466></A><A name=1084></A><A name=3467></A>
<TABLE cellSpacing=2 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD align=middle width="15%"><FONT size=+1><B>Code</B></FONT> </TD>
    <TD align=left><FONT size=+1><B>Meaning</B></FONT> </TD></TR>
  <TR>
    <TD align=middle>r </TD>
    <TD align=left>const </TD></TR>
  <TR>
    <TD align=middle>n </TD>
    <TD align=left>in</TD></TR>
  <TR>
    <TD align=middle>N </TD>
    <TD align=left>inout</TD></TR>
  <TR>
    <TD align=middle>o </TD>
    <TD align=left>out </TD></TR>
  <TR>
    <TD align=middle>O </TD>
    <TD align=left>bycopy </TD></TR>
  <TR>
    <TD align=middle>R </TD>
    <TD align=left>byref </TD></TR>
  <TR>
    <TD align=middle>V </TD>
    <TD align=left>oneway </TD></TR></TBODY></TABLE>
<P><A href="http://toodarkpark.org/computers/objc/coreobjc.html"><IMG 
src="Objective-C Extensions_arquivos/DocsLeftArrow.gif"></A> <A 
href="http://toodarkpark.org/computers/objc/objctoc.html"><IMG 
src="Objective-C Extensions_arquivos/DocsContents.gif"></A> <A 
href="http://toodarkpark.org/computers/objc/runtime.html"><IMG 
src="Objective-C Extensions_arquivos/DocsRightArrow.gif"></A> 
<P>
<HR>
<FONT size=-1>Last Modified: 01:27am , January 19, 1996
<H5></H5>
<CENTER>
<HR>
<A href="http://www.next.com/HotNews/">Hot News</A> | <A 
href="http://www.next.com/OpenStep/">OpenStep</A> | <A 
href="http://www.next.com/WebObjects/">WebObjects</A> | <A 
href="http://www.next.com/Services/">Services</A> | <A 
href="http://www.next.com/BuyNow/">Buy Now</A> | <A 
href="http://www.next.com/NeXTanswers/">NeXTanswers</A> | <A 
href="http://www.next.com/Search/">Search</A> | <A 
href="http://www.next.com/AboutNeXT/">About NeXT</A> 
<HR>
</CENTER>NeXT sales and product information inquiries? <A 
href="http://www.next.com/AboutNeXT/Feedback.html">Click here</A><BR><A 
href="http://www.next.com/Legal/">Copyright</A> 1996 <A 
href="http://www.next.com/">NeXT Software, Inc.</A> <A 
href="http://www.next.com/Legal/">Proprietary Notices.</A> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></BODY></HTML>
